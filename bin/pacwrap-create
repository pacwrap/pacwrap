#!/bin/bash
#
#  PacWrap -- Chroot Initialisation Utility
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
CYAN=$(tput setaf 6)
YELLOW=$(tput setaf 11)
RESET=$(tput sgr0)
BAR="$RED$BOLD::$RESET$BOLD"
BAR_GREEN="$GREEN$BOLD::$RESET$BOLD"
ARROW="$CYAN$BOLD->$RESET"
ARROW_GREEN="$GREEN$BOLD->$RESET"
ARROW_RED="$RED$BOLD->$RESET"

EXEC_NAME="pacwrap-create" 

EXEC_SCRIPT="pacwrap-exec"
SYNC_SCRIPT="pacwrap-sync"

main () {	
	trap abort INT

	parse_args "$@"

	if [[ $SWITCH == v ]]; then
		VER_DISPLAY=$EXEC_NAME pacwrap -v 
		exit	
	fi

	if [[ ! $SANDBOX ]]; then
		echo $EXEC_NAME": Instance not specified."
		exit 1
	fi

	init_vars

	log $BAR_GREEN "Initializing container..."

	init_struct
	init_chroot

	log $BAR_GREEN "Finalizing chroot..."

	finalise

	log $BAR_GREEN "Process complete!"
	echo " Use pacwrap -Esr $BOLD$SANDBOX$RESET to configure the the container."
}

parse_args () {
	ArGS=()
	for var in "$@"; do
		case $var in 
			-v|--version)
				VER_DISPLAY=$EXEC_NAME pacwrap -v
				exit
				;;
			--dep=*)
				DEPEND=$(echo $var | cut -c 7-)
				;;	
			--verbose)
				SWITCH=v$SWITCH
				;;
			--is-dep)
				SWITCH=d$SWITCH
				;;
			--is-root)
				SWITCH=r$SWITCH
				;;
			-C*)
				SWITCH=$(echo $var | cut -c 3-)$SWITCH
				;;
			-*)
				SWITCH=$(echo $var | cut -c 2-)$SWITCH
				;;
			*)
				SANDBOX=$var
				;;
			esac
	done
}

init_vars () {
	INSTANCE_DATA_DIR="$HOME/.local/share/pacwrap"
	INSTANCE_CACHE_DIR="$HOME/.cache/pacwrap/pkg"
	INSTANCE_CONFIG_DIR="$HOME/.config/pacwrap"

	VERBOSE="/dev/null"
	[[ $SWITCH == *v* ]] && VERBOSE="/dev/stdout"	

	if [[ $PACWRAP_DEBUG ]]; then 
		INSTANCE_DATA_DIR="$PACWRAP_DEBUG"
		INSTANCE_CONFIG_DIR="$PACWRAP_DEBUG/cfg"	
	fi

	LOG_FILE="$INSTANCE_DATA_DIR/pacwrap.log"
	OUTPUT_DEST=$LOG_FILE

	INSTANCE_ROOT_DIR=$INSTANCE_DATA_DIR/root
	INSTANCE_HOME_DIR=$INSTANCE_DATA_DIR/home
	INSTANCE_ROOT=$INSTANCE_ROOT_DIR/$SANDBOX
	INSTANCE_HOME=$INSTANCE_HOME_DIR/$SANDBOX
	INSTANCE_CONFIG=$INSTANCE_CONFIG_DIR/root/$SANDBOX

	PACMAN_CONFIG=pacman.install.conf	
	PARAMS="$SANDBOX --root --exec"	
	MACHINE_ID=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)


	##TODO: Standardise output and integrate with logging infrastructure

	if [[ ! -d $INSTANCE_ROOT_DIR ]]; then ## TODO: enhance check and externalise it to pacwrap-utils
		echo $EXEC_NAME": Data directory not found. Aborting." 	
		exit 1
	fi

	if [[ $SWITCH == *d* ]]; then
		ISDEP=1
	fi
	if [[ $SWITCH == *r* ]]; then
		ISROOTDEP=1
		PACMAN_CONFIG=pacman.conf
	fi

	local base_root=$INSTANCE_ROOT_DIR/$DEPEND
	if [[ ! $DEPEND ]] && [[ ! $ISROOTDEP ]]; then
		echo "Root dependency not specified."
		exit 1
	fi

	if [[ -d $INSTANCE_ROOT ]]; then 
		echo $EXEC_NAME": Root directory for $SANDBOX exists. Aborting." 
		exit 1
	fi

	if [[ ! -d $base_root ]] && [[ $DEPEND ]]; then
		echo $EXEC_NAME": Directory not found for $DEPEND root dependency."
		exit 1
	fi


}


init_struct () {
	log $ARROW "Pre-initializing structures.."

	mkdir -p $INSTANCE_ROOT $INSTANCE_HOME \
		$INSTANCE_ROOT/etc \
		$INSTANCE_ROOT/var/lib/pacman \
		$INSTANCE_ROOT/etc/pacman.d/ \
		$INSTANCE_ROOT/etc/fonts/conf.d

	if [[ ! -d $INSTANCE_ROOT ]] || [[ ! -d $INSTANCE_HOME ]]; then 
		echo "Directory creation failed." 
		exit 1
	fi

	cp $INSTANCE_CONFIG_DIR/pacman/pacman.conf $INSTANCE_ROOT/etc/pacman.conf
	cp $INSTANCE_CONFIG_DIR/pacman/pacman.conf $INSTANCE_CONFIG_DIR/pacman/sync/pacman.$SANDBOX.conf
	cp $INSTANCE_CONFIG_DIR/pacman/pacman.conf $INSTANCE_CONFIG_DIR/pacman/syncdb/pacman.$SANDBOX.conf	
	cp $INSTANCE_CONFIG_DIR/pacman/pacman.install.conf $INSTANCE_ROOT/etc/pacman.install.conf
	cp $INSTANCE_CONFIG_DIR/pacman.d/mirrorlist $INSTANCE_ROOT/etc/pacman.d/mirrorlist
	
	echo "$LANG ${LANG#*.}" > $INSTANCE_ROOT/etc/locale.gen
	echo "LANG=$LANG" > $INSTANCE_ROOT/etc/locale.conf
	echo "user:x:1000:1000::/home/user:/bin/bash" >> $INSTANCE_ROOT/etc/passwd
	echo "$MACHINE_ID" > $INSTANCE_ROOT/etc/machine-id
	echo 'PS1="'$SANDBOX'> "' > $INSTANCE_HOME/.bashrc
	local t="ROOT"
	local d=


	if [[ $ISDEP ]] || [[ $ISROOTDEP ]]; then
		cp $INSTANCE_CONFIG_DIR/pacman/pacman.template.conf $INSTANCE_CONFIG_DIR/pacman/template/pacman.$SANDBOX.conf
		mkdir -p $INSTANCE_DATA_DIR/database/$SANDBOX
	fi

	if [[ ! $ISROOTDEP ]]; then
		if [[ -f $INSTANCE_CONFIG_DIR/root/$DEPEND ]]; then
			source $INSTANCE_CONFIG_DIR/root/$DEPEND
			DEPS+=("$DEPEND")
			d="${DEPS[@]}"
		else
			d="$DEPEND"
		fi
	fi	

	if [[ $ISDEP ]]; then
		t="DEP"
	elif [[ $ISROOTDEP ]]; then
		t="BASE"
	fi	

	local config=$(cat << _CONFIG
##
\n## Configuration for $SANDBOX container
\n## generated on $(date "+%F %T") by $EXEC_SCRIPT.
\n##

\n\n# Container type (DO NOT EDIT)
\nTYPE=$t

\n\n# Container dependency array (DO NOT EDIT)
\nDEPS=($d)

\n\n# Forcibly apply pacman -Sy to container
\n# Not applicable to ROOT containers
\nSYNC_PACMANDB=0
_CONFIG
)
	echo -e $config > $INSTANCE_CONFIG
}

init_chroot () {	
	log $ARROW "Bootstrapping base packages..."
	fakechroot fakeroot pacman -Syu \
   	--root $INSTANCE_ROOT \
    	--dbpath $INSTANCE_ROOT/var/lib/pacman \
    	--config $INSTANCE_ROOT/etc/$PACMAN_CONFIG \
	--cache $INSTANCE_CACHE_DIR \
	--logfile "$LOG_FILE" \
    	base lib32-glibc \
	--noconfirm 2>/dev/null 1>>$VERBOSE
	export PACWRAP_CREATE=1
	$SYNC_SCRIPT -yyyy $SANDBOX

	local gnupg=$(get_directory_pop $INSTANCE_DATA_DIR/pacman/gnupg) 
	local sync=$(get_directory_pop $INSTANCE_DATA_DIR/pacman/sync) 

	if [[ $sync == 0 ]]; then
		cp -vr $INSTANCE_ROOT/var/lib/pacman/sync $INSTANCE_DATA_DIR/pacman  1>>$OUTPUT_DEST 2>>$OUTPUT_DEST 
	fi

	if [[ $gnupg == 0 ]]; then
		init_trust	
	fi

}

get_directory_pop() {
	local array=$(ls $1)
	echo ${#array}
}

init_trust () {
	log $BAR_GREEN "Initializing pacman trust database..."
	$EXEC_SCRIPT $PARAMS pacman-key --init 1>>$OUTPUT_DEST 2>>$OUTPUT_DEST
	log $ARROW "Populating pacman trust database..."
	$EXEC_SCRIPT $PARAMS pacman-key --populate 1>>$OUTPUT_DEST 2>>$OUTPUT_DEST
}

finalise () {
	log $ARROW "Generating locale..."
	$EXEC_SCRIPT $PARAMS locale-gen 1>>$OUTPUT_DEST 2>>$OUTPUT_DEST	
	log $ARROW "Updating certificate trust..."
	$EXEC_SCRIPT $PARAMS update-ca-trust 1>>$OUTPUT_DEST 2>>$OUTPUT_DEST

	[[ ! $ISROOTDEP ]] && [[ $DEPEND ]] && sync_foreign_database		
	cleanup
	$SYNC_SCRIPT -g $SANDBOX
}

sync_foreign_database () {
	source $INSTANCE_CONFIG
	local dbsyncpkgs=()
	local i=0
	for dep in ${DEPS[@]}; do
		dbsyncpkgs[i++]="$($EXEC_SCRIPT $dep --root --exec pacman -Qqe | sed -z -E "s/\<base\>|\<lib32-glibc\>//g")"
	done
	if [[ ${dbsyncpkgs[@]} ]]; then
		log $ARROW "Synchronizing pacman database against foreign packages..."
		$EXEC_SCRIPT $PARAMS pacman -Su \
		--dbonly \
		--logfile /tmp/pacman.log \
		--noconfirm ${dbsyncpkgs[@]} 2>/dev/null 1>>$VERBOSE
	fi
}

cleanup () {
	log $ARROW "Some housekeeping..."
	rm -v -r \
	$INSTANCE_ROOT/boot \
	$INSTANCE_ROOT/mnt \
	$INSTANCE_ROOT/root \
	$INSTANCE_ROOT/srv \
	$INSTANCE_ROOT/sys \
	$INSTANCE_ROOT/opt \
	$INSTANCE_ROOT/run \
	$INSTANCE_ROOT/dev \
	$INSTANCE_ROOT/etc/pacman.install.conf \
	$INSTANCE_ROOT/etc/pacman.d/mirrorlist 1>>$OUTPUT_DEST
}

log () {
	echo -e "$@ $RESET"
	local i=
	local log=
	local log_output=()
 	for string in $@; do [[ $string == *[* ]] && continue
        	log_output[i++]="$string"
    	done
	echo -e "[$(date '+%FT%H:%M:%S%z')] [$EXEC_NAME] ${log_output[@]}" >>$LOG_FILE
}

abort () {
	log $BAR "Operation aborted by user."
	exit 1
}

main $@
