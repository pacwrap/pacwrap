#!/bin/bash
#
#  pacwrap -- process script
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common

declare -A PROCESS
declare -A CHILD_PROCESS
declare -A INSTANCE
declare -A START
declare -A CMD_EXEC
declare -A CMD_ARGS
declare -A PROCESS_CHILDREN

KILL_PARAM="-1"
COL_FMT_ARG="T"

main () {
	trap exit INT

	local roots=()
	local rootdeps=()
	local baserootdeps=()
	local syncroots=()
	local links=

	parse_args $@
	init 1

	[[ $SWITCH == Pk* ]] && log_to_file "Running '$RUNTIME_ARGS'"

	case $SWITCH in
		Pk*)	kill_instance ${roots[@]};;
		*)	summary; local sum=$?
			[[ $sum == 1 ]] && log_invalid_arguments $1
		esac
}

script_init () { 
	[[ $SWITCH == Ps* ]] && SHOW_HEADER=1
	[[ $SWITCH == *n* ]] || [[ $SHOW_HEADER ]] && SHOW_CONTAINER=1
	[[ $SWITCH == *id* ]] || [[ $SHOW_HEADER ]] && SHOW_PID=1
	[[ $SWITCH == *a* ]] && SHOW_ARGS=1	
	[[ $SWITCH == *x* ]] && SHOW_EXEC=1
	[[ $SWITCH == *u* ]] && SHOW_UPTIME=1
	[[ $SWITCH == *c* ]] && SHOW_PIDS=1
	[[ $SWITCH == *t* ]] && ENUMERATE_TREE=1
	[[ $SWITCH == *b* ]] && ENUMERATE_BWRAP=1
	[[ $SWITCH == *w* ]] && COL_FMT_ARG="W"

	ENUM_SKIP=$([[ ${ARGS[@]} ]] && echo 1)

	if [[ ${ARGS[@]} ]]; then 
		roots=()
		for instance in $ARGS; do
			roots+=("$instance")
		done
	fi

	enumerate_process_array

	[[ ! ${#PROCESS[@]} > 0 ]] && if [[ ${ARGS[@]} ]]; then	
		log_error "Invalid arguments specified to enumerate." 1
	else
 		log_error "No containers running with $EXEC_SCRIPT to enumerate." 1
	fi
	
}

parse_args () {
	for var in "$@"; do case $var in 
		-[0-9]|-[0-9][0-9])	KILL_PARAM="$var";;
		-n|--noconfirm|--name) 	SWITCH+="n";;
		--enumerate-bwrap|-b)	SWITCH+="b";;
		--enumerate-tree|-t)	SWITCH+="t";;
		--summary|-s)		SWITCH+="s";;
		--identifier|-id)	SWITCH+="id";;
		--wrap|-w)		SWITCH+="w";;
		--uptime|-u)		SWITCH+="s";;
		--args|-a)		SWITCH+="a";;
		--exec|-x)		SWITCH+="x";;
		-k|--kill) 		SWITCH="k";;
		-V|--version)		SWITCH="V";;
		-P*)			SWITCH+="${var:2}";;	
		*)			ARGS+=("$var");;
	esac; done
}

summary() {
	local col_fmt=$([[ $SHOW_ARGS ]] && [[ $SHOW_HEADER ]] && echo -${COL_FMT_ARG}ARGS)
	IFS=; local ps_list=$(enumerate_ps_list ${roots[@]})
	[[ ! $ps_list ]] && return 1	
	echo -e $([[ $SHOW_HEADER ]] && column_headers)$ps_list | column -t --table-columns $(column_params) $col_fmt -d -s $(echo -e '\t')
}

enumerate_process_array() {	
	for i in /proc/[0-9]*; do
		[[ -s $i/cmdline ]] || [[ ! -f $i/cmdline ]] && continue

		local cmdlist=(); while read -r -d '' cmd || [[ $cmd ]]; do
			cmdlist+=("$cmd")
		done <$i/cmdline 

		local pid=${i##*/}	

		[[ ${cmdlist[1]} != *pacwrap* ]] && [[ ${cmdlist[0]} != bwrap ]] && [[ ! ${CHILD_PROCESS[$pid]} ]] && continue
		[[ ${cmdlist[0]} != bwrap ]] && [[ ! ${CHILD_PROCESS[$pid]} ]] && 
		[[ ${cmdlist[1]} != *pacwrap-exec ]] && [[ ${cmdlist[@]} != *-E* ]] && continue

		local instance=

		if [[ ${cmdlist[0]} != bwrap ]]; then 	
			instance=${cmdlist[2]}; [[ ${cmdlist[2]} == -* ]] && 
		      	instance=${cmdlist[3]}
		elif [[ ${CHILD_PROCESS[$pid]} ]]; then
			[[ ! $ENUMERATE_BWRAP ]] && continue
		else
			local bwrap_path=; for cmd in ${cmdlist[@]}; do
				[[ $cmd != $PACWRAP_DATA_DIR/root/* ]] && continue
				bwrap_path=${cmd##*/root/}; instance=${bwrap_path%%/*}
				break
			done; [[ ! $instance ]] && continue
		fi
		
		if [[ ${CHILD_PROCESS[$pid]} ]]; then
			[[ ! $ENUMERATE_TREE ]] && [[ ! $ENUMERATE_BWRAP ]] && continue
			instance="${INSTANCE[${CHILD_PROCESS[$pid]}]}"	
		fi

		local skip=$ENUM_SKIP; for ins in ${roots[@]}; do
			[[ $instance == $ins ]] || [[ $ins == $pid ]] && skip=
		done; [[ $skip ]] && continue

		local cmd="${cmdlist[@]}"
		local pmod=$(stat -c '%Y' /proc/$pid) 
	
		if [[ -f $INSTANCE_RUNTIME_DIR/$pid ]] && [[ $(stat -c '%Y' $INSTANCE_RUNTIME_DIR/$pid) == $pmod ]]; then
			local instance=$instance
			local start=
			local runtime_args=

			source $INSTANCE_RUNTIME_DIR/$pid
			
			CMD_EXEC[$pid]="${cmdlist[1]}"
			cmd=${cmd#*${cmdlist[1]}}
			CMD_ARGS[$pid]="${cmd:1}"
			enumerate_process 1
		elif [[ ${cmdlist[0]} == bwrap ]]; then 
			local parent_id=$(cat /proc/$pid/status | grep PPid); parent_id=${parent_id##*	}
			local parent_runtime=${CMD_EXEC[$parent_id]}
		
			if [[ ! $ENUMERATE_BWRAP ]]; then
				skip=; for p in ${CHILD_PROCESS[@]}; do					
				[[ $p == $pid ]] && skip=1 && break
				done; [[ $skip ]] && continue
			fi
		
			[[ ! $parent_runtime ]] && log_error $LOG_ERR_WARN "Runtime metadata for $pid was not found."

			CMD_EXEC[$pid]="${cmdlist[0]}"	
			CMD_ARGS[$pid]="${cmd#* }"
			enumerate_process
		else
			if [[ ! ${CHILD_PROCESS[$pid]} ]]; then	
				if [[ -f $INSTANCE_RUNTIME_DIR/$pid  ]]; then
					log_error $LOG_ERR_WARN "Runtime metadata for $pid was modified."
				else
					log_error $LOG_ERR_WARN "Runtime metadata for $pid was not found."
				fi
			fi
			CMD_EXEC[$pid]="${cmd%% *}"
			cmd=${cmd# *${cmdlist[0]}}
			CMD_ARGS[$pid]="${cmd#* }"
			enumerate_process
		fi

	done
}

enumerate_process() {
	INSTANCE[$pid]="$instance"	
	PROCESS[$pid]="$pid"		
	START[$pid]="$pmod"

	[[ ! $ENUMERATE_TREE ]] && 
	[[ ! $1 ]] && return 
	
	PROCESS_CHILDREN[$pid]=$(get_child_ids $pid)

	for p in ${PROCESS_CHILDREN[$pid]}; do
		[[ ${CHILD_PROCESS[$p]} ]] ||
		[[ ${PROCESS[$p]} ]] && continue
		CHILD_PROCESS[$p]="$pid"
	done
}


format_time() {
	if [[ $1 -le 60 ]]; then
		printf "%ss" $1
	elif [[ $1 -le 3600 ]]; then	
		local minutes=$(($1/60)) 
		local seconds=$(($1-$((minutes*60))))

		printf "%sm %ss" $minutes $seconds
	elif [[ $1 -gt 3600 ]]; then	
		local hour=$(($1/60/60))
		local minute=$(($1/60))
		local minutes=$(($minute-$((hour*60))))
		local seconds=$(($1-$((minute*60))))
	
		if [[ $1 -lt 86400 ]]; then
			printf "%sh %sm %ss" $hour $minutes $seconds
		else
			printf "%sd %sh %sm %ss" $(($hour/24)) $hour $minutes $seconds
		fi
	fi
}

get_arrow() {
	echo $(if [[ $1 == 0 ]]; then echo $ARROW_GREEN; else echo $ARROW_RED; fi)
}

kill_instance() {
	if [[ ! $SWITCH_NOCONFIRM ]]; then
		printf "$BAR %s $RESET\n\n" "Instances"
		for pid in ${PROCESS[@]}; do 
			echo -n "$BOLD${INSTANCE[$pid]}$RESET ($pid) "
		done; echo -e "\n"
	fi

	[[ ! $(query_confirm_yN "Kill processes") ]] && return

	for parent_pid in ${PROCESS[@]}; do	
		[[ ! -d /proc/$parent_pid/ ]] && continue
		
		for pid in $(get_child_ids ${PROCESS_CHILDREN[$parent_pid]}); do
			[[ ! -d /proc/$pid/ ]] && continue
			kill $KILL_PARAM $pid
			log "$(get_arrow $?) Killed ${INSTANCE[$parent_pid]} ($pid)"
		done
	done
}

get_child_ids() {
	local child="/proc/$1/task/$1/children"
	local pids=()

	while true; do
		local procid=$(cat $child 2>/dev/null) 
		[[ ! $procid ]] && break
		procid=${procid%% *}
		child="/proc/$procid/task/$procid/children"		
		pids+=($procid)
	done

	echo "${pids[@]} "
}

enumerate_ps_list() {
	for pid in ${PROCESS[@]}; do
		local instance=${INSTANCE[$pid]}
		local runtime_args=
		local time=
		local vars=()

		if [[ ${START[$pid]} ]]; then
			time=$(format_time $(($(date +%s)-${START[$pid]})))
		else		
			[[ $SHOW_PID ]] && printf "\n%s" $pid
			continue
		fi
		

		[[ $SHOW_PID ]] && vars+=($pid)
		[[ $SHOW_CONTAINER ]] && vars+=($instance)
		[[ $SHOW_UPTIME ]] &&  vars+=($time)
		[[ $SHOW_PIDS ]] && vars+=("${PROCESS_CHILDREN[$pid]} ")
		[[ $SHOW_EXEC ]] && vars+=(${CMD_EXEC[$pid]})
		[[ $SHOW_ARGS ]] && vars+=(${CMD_ARGS[$pid]})
		[[ ${#vars[@]} > 0 ]] && printf "\n%s\t%s\t%s\t%s\t%s" ${vars[@]}
	done
}

column_headers() {	
	printf "$BOLD%s\t%s\t%s\t%s\t%s$RESET\n" \
		$([[ $SHOW_PID ]] && echo PID) \
		$([[ $SHOW_CONTAINER ]] && echo Container) \
		$([[ $SHOW_UPTIME ]] && echo Uptime) \
		$([[ $SHOW_PIDS ]] && echo Child PIDs) \
		$([[ $SHOW_EXEC ]] && echo Executable) \
		$([[ $SHOW_ARGS ]] && echo Arguments) 	
}

column_params() {
	printf "%s%s%s%s%s%s" \
	$([[ $SHOW_PID ]] && echo PID) \
	$([[ $SHOW_CONTAINER ]] && echo ,CONTAINER) \
	$([[ $SHOW_UPTIME ]] && echo ,UPTIME) \
	$([[ $SHOW_PIDS ]] && echo ,CHILDREN) \
	$([[ $SHOW_EXEC ]] && echo ,EXEC) \
	$([[ $SHOW_ARGS ]] && echo ,ARGS)
}

main $@
