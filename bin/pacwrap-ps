#!/bin/bash
#
#  pacwrap -- process script
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common

declare -A PROCESS
declare -A CHILD_PROCESS
declare -A INSTANCE
declare -A START
declare -A CMD_EXEC
declare -A CMD_ARGS
declare -A PROCESS_CHILDREN
declare -A FLAG_INSTANCE

KILL_PARAM="-1"
COL_FMT_ARG="T"
EXEC_SUBSTRING=${0%%-*}

main () {
	trap exit INT

	local roots=

	parse_args $@
	init 1

	case $SWITCH in
		*k*)	kill_instance ${ROOTS[@]};;
		*)	process_status; local sum=$?
			[[ $sum == 1 ]] && log_invalid_arguments $1
	esac
}

script_init () { 
	[[ $SWITCH == *k* ]] && log_to_file "Running '$RUNTIME_EXEC $RUNTIME_ARGS'"
	[[ $SWITCH == *s* ]] && DISPLAY_COLUMNS=1 
	[[ $SWITCH == *n* ]] || [[ $DISPLAY_COLUMNS ]] && SHOW_CONTAINER=1
	[[ $SWITCH == *id* ]] || [[ $DISPLAY_COLUMNS ]] && SHOW_PID=1
	[[ $SWITCH == *u* ]] && [[ $DISPLAY_COLUMNS ]] && SHOW_UPTIME=1
	[[ $SWITCH == *e* ]] && SHOW_EXEC=1
	[[ $SWITCH == *x* ]] && SHOW_ARGS=1
	[[ $SWITCH == *t* ]] && ENUMERATE_TREE=1
	[[ $SWITCH == *b* ]] && ENUMERATE_BWRAP=1
	[[ $SWITCH == *w* ]] && COL_FMT_ARG="W"

	ENUM_SKIP=$([[ ${ARGS[@]} ]] && echo 1)

	[[ ${ARGS[@]} ]] && for instance in $ARGS; do roots+=("$instance"); done
	
	enumerate_process_array

	[[ ! ${#PROCESS[@]} > 0 ]] && if [[ ${ARGS[@]} ]]; then	
		log_error "Invalid arguments specified to enumerate." 1
	else
 		log_error "No containers running with $EXEC_SCRIPT to enumerate." 1
	fi
	
}

parse_args () {
	for var in "$@"; do case $var in 
		-[0-9]|-[0-9][0-9])	KILL_PARAM="$var";;
		-n|--noconfirm|--name) 	SWITCH+="n";;
		--enumerate-bwrap|-b)	SWITCH+="b";;
		--enumerate-tree|-t)	SWITCH+="t";;
		--status|-s)		SWITCH+="s";;
		--identifier|-id)	SWITCH+="id";;
		--wrap|-w)		SWITCH+="w";;
		--uptime|-u)		SWITCH+="s";;
		--args|-x)		SWITCH+="a";;
		--exec|-e)		SWITCH+="x";;
		-k|--kill) 		SWITCH="k";;
		-V|--version)		SWITCH="V";;
		-P*)			SWITCH+="${var:2}";;	
		*)			ARGS+=("$var");;
	esac; done
}

process_status() {
	if [[ $DISPLAY_COLUMNS ]]; then
		local col_fmt=$([[ $SHOW_ARGS ]] && echo -${COL_FMT_ARG}ARGS)	
		enumerate_ps_list | column -t --table-columns $(column_params) $col_fmt -d -s "$DELIMITER"
	else
		DELIMITER=" "; enumerate_ps_list
	fi
}

enumerate_process_array() {	
	for i in $(ls /proc -tr); do
		[[ -s /proc/$i/cmdline ]] || [[ ! -f /proc/$i/cmdline ]] && continue
		
		read param </proc/$i/stat
		
		local stat=($param)
		local pid=${stat[0]}
		local parent_id=${stat[3]}
		local instance=
		
		[[ ${stat[1]} != "(pacwrap"* ]] && [[ ${stat[1]} != "(bwrap)" ]] && 
		[[ ! ${CHILD_PROCESS[$parent_id]} ]] && [[ ! ${CHILD_PROCESS[$pid]} ]] && continue
		
		local exec_name=${stat[1]:1:${#stat[1]}-2}
		local cmdlist=(); while read -r -d '' cmd || [[ $cmd ]]; do
			cmdlist+=("$cmd")
		done </proc/$i/cmdline		

		[[ $exec_name != bwrap ]] && 
		[[ ! ${CHILD_PROCESS[$parent_id]} ]] && [[ ! ${CHILD_PROCESS[$pid]} ]] &&  
		[[ $exec_name != pacwrap-exec ]] && [[ ${cmdlist[@]} != *-E* ]] && continue
		
		if [[ $exec_name != bwrap ]]; then
 			[[ $exec_name == pacwrap* ]] && 
			      for cmd in ${cmdlist[@]}; do case $cmd in
					-*|*/*|pacwrap*) continue;;
					*) instance=$cmd; break;;
			      esac; done
		elif [[ ${CHILD_PROCESS[$parent_id]} ]] || [[ ${CHILD_PROCESS[$pid]} ]]; then
			[[ ! $ENUMERATE_BWRAP ]] && continue
		else
			local bwrap_path=; for cmd in ${cmdlist[@]}; do
				[[ $cmd != $INSTANCE_ROOT_DIR/* ]] && continue
				bwrap_path=${cmd##*/root/}; instance=${bwrap_path%%/*}
				break
			done; [[ ! $instance ]] && continue
		fi

		if [[ ${CHILD_PROCESS[$pid]} ]]; then
			[[ ! $ENUMERATE_TREE ]] && [[ ! $ENUMERATE_BWRAP ]] && continue
			instance="${INSTANCE[${CHILD_PROCESS[$pid]}]}"
		elif [[ ${CHILD_PROCESS[$parent_id]} ]]; then
			[[ ! $ENUMERATE_TREE ]] && [[ ! $ENUMERATE_BWRAP ]] && continue
			instance="${INSTANCE[${CHILD_PROCESS[$parent_id]}]}"
		fi
		
		if [[ ${roots[@]} ]]; then local skip=$ENUM_SKIP; for ins in ${roots[@]}; do
			[[ $instance == $ins ]] || [[ $ins == $pid ]] && skip= && break; done 
			[[ $skip ]] && continue
		fi


		if [[ ${cmdlist[0]} == bwrap ]] && [[ ! ${PROCESS[$parent_id]} ]] && [[ $parent_id == 1 ]]; then
			log_error $LOG_ERR_WARN "Process fork detected within PID $BOLD$pid$RESET from an instance of $BOLD$instance$RESET."
			FLAG_INSTANCE[$pid]=1
		fi

		enumerate_process
	done
}

enumerate_process() {
	local cmd="${cmdlist[@]}"

	INSTANCE[$pid]="$instance"	
	PROCESS[$pid]="$pid"		
	START[$pid]="$pmod"
	
	if [[ ${cmdlist[1]} == $EXEC_SUBSTRING* ]] && [[ ${cmdlist[0]} == /bin/bash ]]; then
		CMD_EXEC[$pid]="$exec_name"
		cmd=${cmd#*${cmdlist[1]}}
		CMD_ARGS[$pid]="${cmd:1}"
	elif [[ ${cmdlist[0]} == *sh ]]; then
	 	CMD_EXEC[$pid]="${cmdlist[0]} ${cmdlist[1]}"
		log_error $LOG_ERR_WARN "PID $BOLD$pid$RESET is running: $cmd"
		FLAG_INSTANCE[$pid]=1
		cmd=${cmd#*${cmdlist[1]}}
		[[ ${cmdlist[1]} == /* ]] && cmd=${cmd:1}
		CMD_ARGS[$pid]="$cmd"	
	else 	
		CMD_EXEC[$pid]="${cmd%% *}"
		cmd=${cmd# *${cmdlist[0]}}
		CMD_ARGS[$pid]="${cmd#* }"
	fi	

	PROCESS_CHILDREN[$pid]=$(get_child_ids $pid)

	for p in ${PROCESS_CHILDREN[$pid]}; do	
		CHILD_PROCESS[$p]="$pid"
	done

	[[ ${roots[@]} ]] && roots+=(${PROCESS_CHILDREN[$pid]})
}


format_time() {
	if [[ $1 -le 60 ]]; then
		printf "%ss" $1
	elif [[ $1 -le 3600 ]]; then	
		local minutes=$(($1/60)) 
		local seconds=$(($1-$((minutes*60))))

		printf "%sm %ss" $minutes $seconds
	elif [[ $1 -gt 3600 ]]; then	
		local hour=$(($1/60/60))
		local minute=$(($1/60))
		local minutes=$(($minute-$((hour*60))))
		local seconds=$(($1-$((minute*60))))
	
		if [[ $1 -lt 86400 ]]; then
			printf "%sh %sm %ss" $hour $minutes $seconds
		else
			printf "%sd %sh %sm %ss" $(($hour/24)) $hour $minutes $seconds
		fi
	fi
}

get_arrow() {
	echo $(if [[ $1 == 0 ]]; then echo $ARROW_GREEN; else echo $ARROW_RED; fi)
}

kill_instance() {
	if [[ ! $SWITCH_NO_CONFIRM ]]; then
		printf "$BAR %s $RESET\n\n" "Instances"
		for pid in ${PROCESS[@]}; do 
			echo -n "$BOLD${INSTANCE[$pid]}$RESET ($pid) "
		done; echo -e "\n"
	fi

	[[ ! $(query_confirm_yN "Kill processes") ]] && return

	for parent_pid in ${PROCESS[@]}; do	
		[[ ! -d /proc/$parent_pid/ ]] && continue
		kill $KILL_PARAM $parent_pid
		log "$(get_arrow $?) Killed ${INSTANCE[$parent_pid]} ($parent_pid)"
	
		for pid in ${PROCESS_CHILDREN[$parent_pid]}; do
			[[ ! -d /proc/$pid/ ]] && continue
			kill $KILL_PARAM $pid
			log "$(get_arrow $?) Killed ${INSTANCE[$parent_pid]} ($pid)"
		done
	done
}

get_child_ids() {
	local child="/proc/$1/task/$1/children"
	local pids=()

	while true; do
		read procid <$child
		[[ ! $procid ]] && break
		procid=${procid%% *}
		child="/proc/$procid/task/$procid/children"		
		pids+=($procid)
	done

	echo ${pids[@]}
}

enumerate_ps_list() {
	[[ $DISPLAY_COLUMNS ]] && column_headers

	for pid in ${PROCESS[@]}; do
		[[ ${CHILD_PROCESS[$pid]} ]] && continue
		
		local vars=(); print_process; [[ $? == 1 ]] && return 1
	
		if [[ $ENUMERATE_TREE ]] || [[ $ENUMERATE_BWRAP ]]; then
			local children=(${PROCESS_CHILDREN[$pid]})
		
			for pid in ${children[@]}; do [[ ! ${PROCESS[$pid]} ]] && continue
				if [[ $DISPLAY_COLUMNS ]]; then
					local char='c'
					[[ ${children[${#children[@]}-1]} == $pid ]] && char='4'
					printf "\xE2\x94\x9$char\xE2\x94\x80"
				fi
				vars=(); print_process; [[ $? == 1 ]] && return 1
			done
		fi
	done; [[ ! $DISPLAY_COLUMNS ]] && echo; return 0	
}

print_process() {
	IFS=; [[ $DISPLAY_COLUMNS ]] && [[ ${FLAG_INSTANCE[$pid]} ]] && printf "$YELLOW"	
	[[ $SHOW_PID ]] && vars+=($pid)
	[[ $SHOW_CONTAINER ]] && vars+=(${INSTANCE[$pid]})
	[[ $SHOW_UPTIME ]] && vars+=($(format_time $(($(date +%s)-$(stat -c '%Y' /proc/$pid)))))
	[[ $SHOW_EXEC ]] && vars+=(${CMD_EXEC[$pid]})
	[[ $SHOW_ARGS ]] && vars+=(${CMD_ARGS[$pid]})
	
	if [[ ${#vars[@]} > 0 ]]; then
		for output in ${vars[@]}; do
			[[ ! $output ]] && output="-"
			printf "%s$DELIMITER" $output
		done
	else
		return 1
	fi

	[[ $DISPLAY_COLUMNS ]] && printf "$RESET\n"; IFS=$' \t\n'
}

column_headers() {
	IFS=; printf "$BOLD%s\t%s\t%s\t%s\t%s$RESET\n" \
		      $([[ $SHOW_PID ]] && echo PID) \
		      $([[ $SHOW_CONTAINER ]] && echo Container) \
		      $([[ $SHOW_UPTIME ]] && echo Uptime) \
		      $([[ $SHOW_EXEC ]] && echo Executable) \
		      $([[ $SHOW_ARGS ]] && echo Arguments); IFS=$' \t\n'
}

column_params() {
	printf "%s%s%s%s%s%s" \
	$([[ $SHOW_PID ]] && echo PID) \
	$([[ $SHOW_CONTAINER ]] && echo ,CONTAINER) \
	$([[ $SHOW_UPTIME ]] && echo ,UPTIME) \
	$([[ $SHOW_EXEC ]] && echo ,EXEC) \
	$([[ $SHOW_ARGS ]] && echo ,ARGS)
}

main $@
