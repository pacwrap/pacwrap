#!/bin/bash
#
#  PacWrap -- Chroot Invocator
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common

main () {
	parse_args "$@"
	init 1

	case $SWITCH in 
		*pS*|*pQ*|*pR*)	execute_pacman;;
		*rc*|*cr*)	execute_fakeroot "${ARGS[@]}";;		
		*rs*|*sr*)	execute_fakeroot bash;;
		*s)		execute_sandbox bash;;
		*)		execute_sandbox "${ARGS[@]}";;
	esac
}

script_init () {
	[[ ! $INSTANCE ]] &&
		log_error $LOG_ERR_HELP "Target not specified." 1
	
	INSTANCE_ROOT=$INSTANCE_ROOT_DIR/$INSTANCE
	INSTANCE_HOME=$INSTANCE_HOME_DIR/$INSTANCE
	INSTANCE_USER=user
	INSTANCE_HOME_MOUNT=/home/$INSTANCE_USER
	INSTANCE_SCRIPT="$PACWRAP_CONFIG_DIR/bwrap/$INSTANCE.sh"
	
	[[ ! -d $INSTANCE_ROOT ]] || [[ ! -d $INSTANCE_HOME ]] &&
		log_error $LOG_ERR_HELP "Container $INSTANCE not found." 1

	[[ ! -d $INSTANCE_RUNTIME_DIR ]] && mkdir $INSTANCE_RUNTIME_DIR
	
	touch $INSTANCE_RUNTIME_DIR/$$
	trap on_exit_invocation EXIT	
}

parse_args () {
	local sbdefined=; for var in "$@"; do case $var in 
		-v|--verbose)	SWITCH+="v";;
		--explicit)	continue;;
		--pacman)	SWITCH+="p";;
		-V|--version)	SWITCH="V";;
		--root)		SWITCH+="r";;
		--shell)	SWITCH+="s";;
		--exec)		SWITCH+="rc";;	
		-E*)		SWITCH+="${var:2}";;
		-*|-Q*|-R*)	if [[ $SWITCH == Ep* ]]; then SWITCH+="${var:1}"; else ARGS+=("$var"); fi;;
		*)		[[ $sbdefined ]] && ARGS+=("$var") && continue		
				INSTANCE=$var
				sbdefined=1;;
	esac; done
}

execute_pacman() {
	local runtime_args="pacman -${SWITCH:2}"
	
	[[ ${#ARGS[@]} > 0 ]] && runtime_args+=" ${ARGS[@]}"
	([[ $SWITCH == *S* ]] || [[ $SWITCH == *R* ]]) &&
	 [[ ! $(query_confirm_yN "Execute $RESET'$YELLOW$runtime_args$RESET'$BOLD on $INSTANCE") ]] && return
	
	execute_fakeroot $runtime_args --noconfirm --log=/tmp/pacman.log 2>$VERBOSE
	[[ $? == 0 ]] && 
	([[ $SWITCH == *S ]] || [[ $SWITCH == *R* ]]) && 
	$SYNC_SCRIPT -Sgp $INSTANCE
}

check_concurrent() {
	[[ ! $1 ]] && return

	local processes=($($PS_SCRIPT -Pid $INSTANCE 2>/dev/null))

	[[ ${#processes[@]} -gt $1 ]] && 
		log_error "Concurrency limit exceeded: $1 > ${#processes[@]}." 1
}

execute_sandbox () {
	[[ ! -f $INSTANCE_SCRIPT ]] && 
		log_error $LOG_ERR_HELP	"Script $INSTANCE_SCRIPT not found." 1

	check_concurrent $(return_concurrent_limit $INSTANCE)
	
	source $INSTANCE_SCRIPT
}

execute_fakeroot() {
	(exec bwrap \
	--bind $INSTANCE_ROOT / \
	--ro-bind /usr/lib/libfakeroot /usr/lib/libfakeroot/ \
	--ro-bind /usr/bin/fakeroot /usr/bin/fakeroot \
	--ro-bind /usr/bin/fakechroot /usr/bin/fakechroot \
	--ro-bind /usr/bin/faked /usr/bin/faked \
	--ro-bind /etc/resolv.conf /etc/resolv.conf \
	--ro-bind /etc/localtime /etc/localtime \
	--bind $INSTANCE_PACMAN_SYNC /var/lib/pacman/sync \
	--bind $INSTANCE_PACMAN_GNUPG /etc/pacman.d/gnupg \
	--bind $INSTANCE_PACMAN_CACHE /var/cache/pacman/pkg \
	--dev /dev \
	--proc /proc \
	--tmpfs /tmp \
	--ro-bind $(return_pacman_syncdb) /tmp/pacman.conf \
	--ro-bind $(return_pacman_sync) /etc/pacman.conf \
	--ro-bind $INSTANCE_PACMAN_MIRRORLIST /etc/pacman.d/mirrorlist \
	--bind $LOG_FILE /tmp/pacman.log \
	--bind $INSTANCE_HOME $INSTANCE_HOME_MOUNT \
	--unshare-all \
	--share-net \
	--clearenv \
	--hostname "FakeChroot" \
	--setenv CWD $INSTANCE_HOME_MOUNT \
	--setenv HOME $INSTANCE_HOME_MOUNT \
	--setenv USER $INSTANCE_USER \
	--setenv PATH /usr/bin \
	--setenv TERM xterm \
	--setenv FREETYPE_PROPERTIES $FREETYPE_PROPERTIES \
	--new-session \
	--die-with-parent \
	fakechroot fakeroot "$@")
}

on_exit_invocation() {
	[[ -f $XDG_RUNTIME_DIR/.pacwrap/$$ ]] && rm $XDG_RUNTIME_DIR/.pacwrap/$$
	on_exit
}

on_exit() {
	return
}

main $@
