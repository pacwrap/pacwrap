#!/bin/bash
#
#  PacWrap -- Chroot Invocator
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common


main () {
	parse_args "$@"
	init 1

	case $SWITCH in 
		*pS*|*pQ*|*pR*)	execute_pacman;;
		*rc*|*cr*)	execute_fakeroot "${ARGS[@]}";;		
		*rs*|*sr*)	execute_fakeroot bash;;
		*s)		launch_container bash;;
		*)		launch_container "${ARGS[@]}";;
	esac
}

script_init() {
	check_root $INSTANCE

	INSTANCE_ROOT=$INSTANCE_ROOT_DIR/$INSTANCE
	INSTANCE_HOME=$INSTANCE_HOME_DIR/$INSTANCE
	INSTANCE_USER=$INSTANCE
	INSTANCE_HOME_MOUNT=/home/$INSTANCE_USER
	INSTANCE_RUNTIME=$INSTANCE_RUNTIME_DIR/$$
	INSTANCE_SCRIPT="$PACWRAP_CONFIG_DIR/bwrap/$INSTANCE.sh"
	BWRAP_ENV=("--setenv XDG_RUNTIME_DIR $XDG_RUNTIME_DIR" "--setenv LANG $LANG")
	BWRAP_ENV_PATH="/usr/bin/:/bin/"
	BWRAP_DEV=("--dev /dev/" "--proc /proc")
	DBUS_FILTER=("--filter")
	EXIT_CONDITION="--die-with-parent"
	SESSION="--new-session"
	
	[[ $SWITCH == *s* ]] && BWRAP_ENV+=("--setenv TERM xterm")
	[[ ! -d "$INSTANCE_HOME" ]] && 
		log_error $LOG_ERR_HELP "$INSTANCE' home directory is missing!" 1
	[[ ! -d "$INSTANCE_RUNTIME_DIR" ]] && mkdir "$INSTANCE_RUNTIME_DIR"

	exec 3> $XDG_RUNTIME_DIR/.pacwrap/$$	
	trap on_exit_invocation EXIT

	load_configuration $INSTANCE
}

parse_args () {
	local sbdefined=; for var in "$@"; do case $var in 
		--pacman|--explicit|--execute)	continue;;
		--no-confirm)			SWITCH_NO_CONFIRM=1;;	
		--root)				SWITCH+="r";;
		--shell)			SWITCH+="s";;
		--exec)				SWITCH+="rc";;	
		-E*)				SWITCH+="${var:2}";;
		-*|-Q*|-R*)			if [[ $SWITCH == Ep* ]]; then SWITCH+="${var:1}"; else ARGS+=("$var"); fi;;
		*)				[[ $sbdefined ]] && ARGS+=("$var") && continue		
						INSTANCE=$var
						sbdefined=1;;
	esac; done
}

execute_pacman() {
	check_fakeroot

	local runtime_args="pacman -${SWITCH:2}"
	
	[[ ${#ARGS[@]} > 0 ]] && runtime_args+=" ${ARGS[@]}"
	([[ $SWITCH == *S* ]] || [[ $SWITCH == *R* ]]) &&
	 [[ ! $(query_confirm_yN "Execute $RESET'$YELLOW$runtime_args$RESET'$BOLD on $INSTANCE") ]] && return
	
	execute_fakeroot $runtime_args --noconfirm --log=/tmp/pacman.log 2>$VERBOSE
	
	[[ $? == 0 ]] && 
	([[ $SWITCH == *S ]] || [[ $SWITCH == *R* ]]) && 
	$SYNC_SCRIPT -Sgp $INSTANCE
}

launch_container() {
	[[ ! $@ ]] && log_error "Runtime arguments not specified." 1
	check_concurrent ${INSTANCE_CONFIG[$INSTANCE,$CONF_CONCURRENT_LIMIT]}

	case ${INSTANCE_CONFIG[$INSTANCE,$CONF_SCRIPT]} in 
		1)		check_file "Script" "$INSTANCE_SCRIPT"
				source "$INSTANCE_SCRIPT";;
		*)		parse_mount_params "$(return_mount $INSTANCE)" 
				parse_permission_params "${INSTANCE_CONFIG[$instance,$CONF_PERMS]}"
				parse_env_params "${INSTANCE_CONFIG[$INSTANCE,$CONF_ENV]}"
				execute_instance $@
	esac
}

start_dbus_proxy() {
	INSTANCE_DBUS_SOCKET=$INSTANCE_RUNTIME_DIR/dbus_$$
	touch "$INSTANCE_DBUS_SOCKET"	
	parse_dbus_params "${INSTANCE_CONFIG[$INSTANCE,$CONF_DBUS]}"
	xdg-dbus-proxy $DBUS_SESSION_BUS_ADDRESS $INSTANCE_DBUS_SOCKET ${DBUS_FILTER[@]} &
	DBUS_JOB=$!	
}

execute_instance() {
	# After initiating the xdg-dbus-proxy job, sleep until D-Bus socket is active.
	# This solves an occasional race condition.
	# Sleep shouldn't occur for longer than 10-20 milliseconds of real time;
	# and if it does, something has gone extraordinarily wrong.
	
	[[ $INSTANCE_DBUS_SOCKET ]] &&
		while [[ ! -S $INSTANCE_DBUS_SOCKET ]]; do
			[[ $it == 100 ]] && log_error "xdg-dbus-proxy socket timed out." 1
			sleep 0.01; ((it++))
		done; it=

	(exec bwrap ${BWRAP_BIND[@]} ${BWRAP_RUNTIME[@]} ${BWRAP_DEV[@]} --sync-fd 3 --unshare-all --clearenv ${BWRAP_ENV[@]} $SESSION $EXIT_CONDITION "$@")
	local exitcode=$?; [[ $EXIT_CONDITION ]] && return $exitcode
	local fthreshold=2; [[ $INSTANCE_DBUS_SOCKET ]] && ((fthreshold++)); FOPEN=($(fuser $INSTANCE_RUNTIME 2>/dev/null))
	while [[ ${#FOPEN[@]} -gt $fthreshold ]]; do sleep 5; FOPEN=($(fuser $INSTANCE_RUNTIME 2>/dev/null)); done; return $exitcode
}

parse_dbus_params() {
	IFS=';'; for param in $1; do
		param=${param/ /}
		local param_space=${param//:/ }
		local params=(${param_space##*${param%%:*} })

		case $param in
			"")		continue;;	
			LOG)		DBUS_FILTER+=("--log");;
			APPINDICATOR)	DBUS_FILTER+=("--own=org.kde.*"
						      "--broadcast=org.kde.StatusNotifierWatcher=@/StatusNotifierWatcher");;
			XDG_PORTAL)	DBUS_FILTER+=("--call=org.freedesktop.portal.*=*"
       						      "--broadcast=org.freedesktop.portal.*=@/org/freedesktop/portal/*")
					BWRAP_ENV_PATH="/usr/lib/flatpak-xdg-utils/:$BWRAP_ENV_PATH";;
			BROADCAST:*)	DBUS_FILTER+=("--broadcast=$params");;	
			CALL:*)		DBUS_FILTER+=("--call=$params");;	
			OWN:*)		DBUS_FILTER+=("--own=$params");;	
			TALK:*)		DBUS_FILTER+=("--talk=$params");;	
			SEE:*)		DBUS_FILTER+=("--see=$params");;		
			*)		log_error $LOG_ERR_WARN "Invalid parameter: '$param'"
		esac
	done; IFS=$' \t\n'
}


parse_mount_params() {
	IFS=';'; for param in $1; do param=${param/ /};	IFS=$' \t\n'
		local param_space=${param//:/ }
		local params=(${param_space##*${param%%:*} })

		[[ $param == *%HOME%* ]] && param=${param//%HOME%/$HOME}
		[[ $param == *%INS_HOME%* ]] && param=${param//%INS_HOME%/$INSTANCE_HOME_MOUNT}	

		case $param in
			"")		continue;;	
			ROOT)		BWRAP_BIND+=("--ro-bind $INSTANCE_ROOT/usr /usr"
						     "--ro-bind $INSTANCE_ROOT/etc /etc"
						     "--symlink /usr/lib /lib64"
						     "--symlink /usr/lib /lib"
					             "--symlink /usr/bin /bin"
					             "--symlink /usr/bin /sbin");;
			HOME) 		BWRAP_BIND+=("--bind $INSTANCE_HOME $INSTANCE_HOME_MOUNT")
					BWRAP_ENV+=("--setenv HOME $INSTANCE_HOME_MOUNT")
					BWRAP_ENV+=("--setenv USER $INSTANCE_USER");;
			HOME_RO) 	BWRAP_BIND+=("--ro-bind $INSTANCE_HOME $INSTANCE_HOME_MOUNT")
					BWRAP_ENV+=("--setenv HOME $INSTANCE_HOME_MOUNT")
					BWRAP_ENV+=("--setenv USER $INSTANCE_USER");;	
			ROOT_RW)	BWRAP_BIND+=("--bind $INSTANCE_ROOT /");;
			RO_HOME:*)	check_mount $HOME/$params
					BWRAP_BIND+=("--ro-bind $HOME/$params $INSTANCE_HOME_MOUNT/$params");;	
			RW_HOME:*)	check_mount $HOME/$params
					BWRAP_BIND+=("--bind $HOME/$params $INSTANCE_HOME_MOUNT/$params");;
			RO:*:*)		check_mount ${params[0]}
					BWRAP_BIND+=("--ro-bind ${params[0]} ${params[1]}");;
			RO:*)		check_mount $params
					BWRAP_BIND+=("--ro-bind $params $params");;
			RW:*:*)		check_mount ${params[0]}
					BWRAP_BIND+=("--bind ${params[0]} ${params[1]}");;	
			RW:*)		check_mount $params
					BWRAP_BIND+=("--bind $params $params");;
			ROOT:*)		check_mount $INSTANCE_ROOT$params
					BWRAP_BIND+=("--ro-bind $INSTANCE_ROOT$params $params");;
			HOME:*)		check_mount ${params[1]}
					BWRAP_BIND+=("--bind ${params[1]} /home/${params[0]}")
					BWRAP_ENV+=("--setenv HOME /home/${params[0]}")
					BWRAP_ENV+=("--setenv USER ${params[0]}");;
			TMPFS:*)	BWRAP_BIND+=("--tmpfs $params");;	
			LINK:*:*)	BWRAP_BIND+=("--symlink ${params[0]} ${params[1]}");;
			*)		log_error $LOG_ERR_WARN "Invalid parameter: '$param'"
		esac
	done; IFS=$' \t\n'
}

check_mount() {
	[[ ! -f $1 ]] && [[ ! -d $1 ]] &&
		log_error "'$1': Invalid mountpoint specified." 1

}

parse_permission_params() {
	IFS=';'; for param in $1; do param=${param/ /}
		local param_space=${param//:/ }
		local params=(${param_space##*${param%%:*} })

		case $param in	
			"")		continue;;
			NONE)		break;;
			ALLOW_FORKING)	EXIT_CONDITION=;;
			RETAIN_SESSION)	SESSION=;;
			DBUS)		start_dbus_proxy
					BWRAP_RUNTIME+=("--ro-bind $INSTANCE_DBUS_SOCKET $XDG_RUNTIME_DIR/bus"
							"--symlink $XDG_RUNTIME_DIR/bus /run/dbus/system_bus_socket")
					BWRAP_ENV+=("--setenv DBUS_SESSION_BUS_ADDRESS $DBUS_SESSION_BUS_ADDRESS");;
			DBUS_SYS)	BWRAP_RUNTIME+=("--ro-bind $XDG_RUNTIME_DIR/bus $XDG_RUNTIME_DIR/bus"
							"--symlink $XDG_RUNTIME_DIR/bus /run/dbus/system_bus_socket")
			    		BWRAP_ENV+=("--setenv DBUS_SESSION_BUS_ADDRESS $DBUS_SESSION_BUS_ADDRESS");;
			X11)		BWRAP_RUNTIME+=("--ro-bind $XAUTHORITY $XDG_RUNTIME_DIR/Xauthority"
				             		"--ro-bind /tmp/.X11-unix/X0 /tmp/.X11-unix/X0")
			    		BWRAP_ENV+=("--setenv XAUTHORITY $XAUTHORITY"
						    "--setenv DISPLAY $DISPLAY");;
			DRI)		BWRAP_DEV+=("--dev-bind-try /dev/dri /dev/dri");;
			NV)		BWRAP_DEV+=("--dev-bind-try /dev/nvidia0 /dev/nvidia0")
					BWRAP_DEV+=("--dev-bind-try /dev/nvidiactl /dev/nvidiactl")
					BWRAP_DEV+=("--dev-bind-try /dev/nvidia-modeset /dev/nvidia-modeset");;
			CUDA)		BWRAP_DEV+=("--dev-bind-try /dev/nvidia-uvm /dev/nvidia-uvm");;
		     	NET)		BWRAP_ENV+=("--share-net")
					BWRAP_BIND+=("--ro-bind /etc/resolv.conf /etc/resolv.conf");;
			
			DEV:*)		BWRAP_DEV+=("--dev-bind-try /dev/$params /dev/$params");;
			PCI_ROOT)	BWRAP_BIND+=("--ro-bind /sys/devices/pci0000:00 /sys/devices/pci0000:00");;	
			PCI_DEV:*)	BWRAP_BIND+=("--ro-bind /sys/bus/pci/devices/0000:$params /sys/bus/pci/devices/0000:$params");;
			PIPEWIRE)	BWRAP_RUNTIME+=("--ro-bind $XDG_RUNTIME_DIR/pipewire-0 $XDG_RUNTIME_DIR/pipewire-0");;
			PULSEAUDIO)	BWRAP_RUNTIME+=("--ro-bind $XDG_RUNTIME_DIR/pulse $XDG_RUNTIME_DIR/pulse");;
			HOSTNAME:*)	BWRAP_ENV+=("--hostname $params");;
			*)		log_error $LOG_ERR_WARN "Invalid parameter: '$param'"
		esac
	done; IFS=$' \t\n'
}

parse_env_params() {
	IFS=';'; for param in $1; do param=${param/ /}; 
		case $param in
			PREPEND_PATH:*)	BWRAP_ENV_PATH="${param##*PATH:}:$BWRAP_ENV_PATH";;
			PATH:*)		BWRAP_ENV_PATH+="${param##*PATH:}";;
			*)		BWRAP_ENV+=("--setenv ${param//:/ }")
		esac
	done; IFS=$' \t\n'
	BWRAP_ENV+=("--setenv PATH $BWRAP_ENV_PATH")
}

execute_fakeroot() {
	check_fakeroot

	(exec bwrap \
	--bind "$INSTANCE_ROOT" / \
	--tmpfs /tmp \
	--ro-bind /usr/lib/libfakeroot /usr/lib/libfakeroot/ \
	--ro-bind /usr/bin/fakeroot /usr/bin/fakeroot \
	--ro-bind /usr/bin/fakechroot /usr/bin/fakechroot \
	--ro-bind /usr/bin/faked /usr/bin/faked \
	--ro-bind /etc/resolv.conf /etc/resolv.conf \
	--ro-bind /etc/localtime /etc/localtime \
	--ro-bind "$(return_pacman_syncdb)" /tmp/pacman.conf \
	--ro-bind "$(return_pacman_sync)" /etc/pacman.conf \
	--ro-bind "$INSTANCE_PACMAN_MIRRORLIST" /etc/pacman.d/mirrorlist \
	--bind "$INSTANCE_PACMAN_SYNC" /var/lib/pacman/sync \
	--bind "$INSTANCE_PACMAN_GNUPG" /etc/pacman.d/gnupg \
	--bind "$INSTANCE_PACMAN_CACHE" /var/cache/pacman/pkg \
	--bind "$LOG_FILE" /tmp/pacman.log \
	--bind "$INSTANCE_HOME" $INSTANCE_HOME_MOUNT \
	--dev /dev \
	--proc /proc \
	--unshare-all \
	--share-net \
	--clearenv \
	--hostname "FakeChroot" \
	--setenv CWD $INSTANCE_HOME_MOUNT \
	--setenv HOME $INSTANCE_HOME_MOUNT \
	--setenv USER $INSTANCE_USER \
	--setenv PATH /usr/bin \
	--setenv TERM xterm \
	--new-session \
	--die-with-parent \
	fakechroot fakeroot "$@")
}

check_fakeroot() {
	[[ ${INSTANCE_CONFIG[$INSTANCE,$CONF_TYPE]} == LINK ]] &&
		log_error "Symbolically linked containers cannot operated on through a fakeroot shell." 1
	
}

check_concurrent() {
	[[ ! $1 ]] && return

	local processes=($($PS_SCRIPT -Pid $INSTANCE 2>/dev/null))

	[[ ${#processes[@]} -gt $1 ]] && 
		log_error "Concurrency limit exceeded: ${#processes[@]} > $1." 1
}

on_exit_invocation() {
	if [[ $INSTANCE_DBUS_SOCKET ]] && [[ -S $INSTANCE_DBUS_SOCKET ]]; then
		disown $DBUS_JOB
		kill -1 $DBUS_JOB
		rm $INSTANCE_DBUS_SOCKET
	fi
	
	[[ -f $INSTANCE_RUNTIME ]] && rm $INSTANCE_RUNTIME
	[[ $INSTANCE_DBUS_SOCKET ]] && [[ -f $INSTANCE_DBUS_SOCKET ]] &&
		rm $INSTANCE_DBUS_SOCKET	

	[[ ! $EXIT_CONDITION ]] &&
		for ((i=$((${#FOPEN[@]}-1)); i>0; i--)); do [[ -d /proc/${FOPEN[i]} ]] && kill -9 ${FOPEN[i]}; done	

	on_exit
}

on_exit() {
	return
}

main $@
