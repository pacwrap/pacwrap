#!/bin/bash
#
#  pacwrap -- common script
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

ARGS=()

[[ $RUNTIME_EXEC ]] && return 

RUNTIME_EXEC="$0"
RUNTIME_ARGS="$@"
EXEC_NAME="${0##*/}"

BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
CYAN=$(tput setaf 6)
YELLOW=$(tput setaf 11)
RESET=$(tput sgr0)
UNDERLINE=$(tput smul)

DELIMITER=$'\t'

BAR="$RED$BOLD::$RESET$BOLD"
BAR_GREEN="$GREEN$BOLD::$RESET$BOLD"
ARROW="$CYAN$BOLD->$RESET"
ARROW_GREEN="$GREEN$BOLD->$RESET"
ARROW_RED="$RED$BOLD->$RESET"

CREATE_SCRIPT="pacwrap"
PS_SCRIPT="pacwrap"

LOG_ERR_HELP=1
LOG_ERR_WARN=2
LOG_ERR_ERROR=3

CONF_TYPE=0
CONF_DEPS=1
CONF_SYNCDB=2
CONF_PKGS=3

[[ ! $PACWRAP_DATA_DIR ]] && PACWRAP_DATA_DIR="$HOME/.local/share/pacwrap"
[[ ! $PACWRAP_CACHE_DIR ]] && PACWRAP_CACHE_DIR="$HOME/.cache/pacwrap"
[[ ! $PACWRAP_CONFIG_DIR ]] && PACWRAP_CONFIG_DIR="$HOME/.config/pacwrap"
[[ ! $PACWRAP_PACCACHE_ARGUMENTS ]] && PACWRAP_PACCACHE_ARGUMENTS="-rk 1"

LOG_FILE="$PACWRAP_DATA_DIR/pacwrap.log"
OUTPUT_DEST=$LOG_FILE

declare -A INSTANCE_CONFIG

INSTANCE_ROOT_DIR=$PACWRAP_DATA_DIR/root
INSTANCE_HOME_DIR=$PACWRAP_DATA_DIR/home
INSTANCE_CONFIG_DIR=$PACWRAP_CONFIG_DIR/container

INSTANCE_PACMAN_CACHE="$PACWRAP_CACHE_DIR/pkg"

init() {	
	[[ $SWITCH == *n* ]] && SWITCH_NO_CONFIRM=1
	[[ $SWITCH == *V* ]] ||
	[[ $SWITCH == h* ]] && manual_script

	script_init
}

load_configuration_all() {
	load_configuration $(ls -U -1F "$INSTANCE_ROOT_DIR" 2>/dev/null | grep ".*[@/]" | tr -d "/@")
}

load_configuration() {
	for instance in $@; do
		source_configuration
		populate_configuration
		populate_container_array
		reset_configuration_params
	done
}

manual_script() {
	pacwrap $RUNTIME_ARGS
	exit
}

populate_container_array() {
	case ${INSTANCE_CONFIG[$instance,0]} in
		BASE)	BASEROOTDEPS+=($instance);;	
		DEP)	ROOTDEPS+=($instance);;
		ROOT)	ROOTS+=($instance);;
		LINK)	LINKS+=($instance);;
	esac
}

source_configuration() {
	eval $(pacwrap --compat --load $instance)
}

reset_configuration_params() {
	TYPE=; DEPS=; 	
	PKGS=; SYNC_PACMANDB=
}

populate_configuration() {
	INSTANCE_CONFIG[$instance,2]=$SYNC_PACMANDB
}

return_sync_pacmandb() {
	echo ${INSTANCE_CONFIG[$instance,2]}
}

return_base() {
	[[ $(return_type) == "BASE" ]] && echo $instance && return 
	local deps=(${INSTANCE_CONFIG[$instance,1]})
	echo ${deps[0]}
}

return_dependencies() {
	echo ${INSTANCE_CONFIG[$instance,1]}
}

return_packages() {
	echo ${INSTANCE_CONFIG[$instance,3]}
}

return_type() {
	echo ${INSTANCE_CONFIG[$instance,0]}
}

return_dependency() {
	local deps=(${INSTANCE_CONFIG[$instance,1]})
	echo ${deps[$((${#deps[@]} - 1))]}
}

log () {
	printf "%s$RESET\n" "$1"
	[[ $2 ]] && case $2 in
		1)	log_to_file "$1";;
		*)	log_to_file "$2";;
	esac
}

log_error() {
	case $1 in
		$LOG_ERR_HELP)	printf "%s %s\n%s\n" "$EXEC_NAME error:" "$2" \
					"Try 'pacwrap -h' for more information on valid operational parameters."
				exit;;
		$ARROW_RED)	printf "$BOLD${RED}error:$RESET %s\n%s\n" "$2" "$3"	>&2
				log_to_file "$2"
				[[ $4 ]] && exit $4;;
		$LOG_ERR_WARN)	printf "$BOLD$YELLOW%s$RESET %s\n" "warning:" "$2" >&2
				[[ $3 ]] && exit $3;;
		*)		printf "$BOLD$RED%s$RESET %s\n" "error:" "$1" >&2
				[[ $2 ]] && exit $2;;
	esac
}

log_to_file() {
	printf "[%s] [%s] %s\n" $(date '+%FT%H:%M:%S%z') $EXEC_NAME "$1" >>"$LOG_FILE"
}

query_confirm_yN () {
	if [[ $SWITCH_NO_CONFIRM ]]; then		
		echo 1	
		return
	fi
	read -rp "$BAR $@ [y/N]$RESET " input
	if [[ "$input" != "y" ]] && 
	   [[ "$input" != "Y" ]] &&
	   ([[ "$input" == "" ]] ||
	   [[ "$input" != "" ]]); then
		return	
	fi
	echo 1
}

query_confirm_Yn () {
	if [[ $SWITCH_NO_CONFIRM ]]; then		
		echo 1	
		return
	fi
	read -rp "$BAR $@ [Y/n]$RESET " input
	if [[ "$input" != "Y" ]] && 
	   [[ "$input" != "y" ]] &&
           [[ "$input" != "" ]]; then
		return	
	fi
	echo 1
}

log_invalid_arguments() {
	if [[ $1 ]]; then log_error $LOG_ERR_HELP "invalid arguments -- '$RUNTIME_ARGS'"	
		     else log_error "operation not specified." 2; fi
}

test_argument() {
	[[ ! $2 ]] && log_error $LOG_ERR_HELP "$1 not specified." 1
}

check_root() {
	case $1 in
		1)	[[ ! $2 ]] && log_error $LOG_ERR_HELP "Target not specified." 1
			[[ -d "$INSTANCE_ROOT_DIR/$2" ]] &&
				log_error "Target container $BOLD$2$RESET: already exists!" 1;;
		*)	[[ ! $1 ]] && log_error $LOG_ERR_HELP "Target not specified." 1
			[[ ! -d "$INSTANCE_ROOT_DIR/$1" ]] &&
				log_error "Target container $BOLD$1$RESET: not found." 1; esac
}

check_file() {
	case $3 in
		1) 	[[ -f "$2" ]] &&
				log_error "$1 '${2##*/}': already exists!" 1;;
		*)	[[ ! -f "$2" ]] &&
				log_error "$1 '${2##*/}': not found." 1; esac
}
