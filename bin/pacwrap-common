#!/bin/bash
#
#  Pacwrap -- common script
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

ARGS=()

[[ $RUNTIME_EXEC ]] && return 

RUNTIME_EXEC="$0"
RUNTIME_ARGS="$@"
EXEC_NAME="${0##*/}"

BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
CYAN=$(tput setaf 6)
YELLOW=$(tput setaf 11)
RESET=$(tput sgr0)
UNDERLINE=$(tput smul)

DELIMITER=$'\t'

BAR="$RED$BOLD::$RESET$BOLD"
BAR_GREEN="$GREEN$BOLD::$RESET$BOLD"
ARROW="$CYAN$BOLD->$RESET"
ARROW_GREEN="$GREEN$BOLD->$RESET"
ARROW_RED="$RED$BOLD->$RESET"

VER="v0.9.19 "

MAN_SCRIPT="pacwrap-man"
EXEC_SCRIPT="pacwrap"
CREATE_SCRIPT="pacwrap-create"
UTILS_SCRIPT="pacwrap-utils"
SYNC_SCRIPT="pacwrap"
PS_SCRIPT="pacwrap-ps"

LOG_ERR_HELP=1
LOG_ERR_WARN=2
LOG_ERR_ERROR=3

CONF_TYPE=0
CONF_DEPS=1
CONF_SYNCDB=2
CONF_PKGS=3
CONF_CONCURRENT_LIMIT=4
CONF_MOUNT=5
CONF_PERMS=6
CONF_ENV=7
CONF_DBUS=8
CONF_SCRIPT=9

[[ ! $PACWRAP_DATA_DIR ]] && PACWRAP_DATA_DIR="$HOME/.local/share/pacwrap"
[[ ! $PACWRAP_CACHE_DIR ]] && PACWRAP_CACHE_DIR="$HOME/.cache/pacwrap"
[[ ! $PACWRAP_CONFIG_DIR ]] && PACWRAP_CONFIG_DIR="$HOME/.config/pacwrap"
[[ ! $PACWRAP_PACCACHE_ARGUMENTS ]] && PACWRAP_PACCACHE_ARGUMENTS="-rk 1"
[[ ! $PACWRAP_PASSTHROUGH_CMD ]] && PACWRAP_PASSTHROUGH_CMD="sudo pacman"

VERBOSE="/dev/null"

LOCK_FILE="$PACWRAP_DATA_DIR/pacwrap.lck"	
LOG_FILE="$PACWRAP_DATA_DIR/pacwrap.log"
OUTPUT_DEST=$LOG_FILE

declare -A INSTANCE_CONFIG
declare -A PKGLIST_EXPLICIT

INSTANCE_ROOT_DIR=$PACWRAP_DATA_DIR/root
INSTANCE_HOME_DIR=$PACWRAP_DATA_DIR/home
INSTANCE_CONFIG_DIR=$PACWRAP_CONFIG_DIR/instance
INSTANCE_LC_DIR=$PACWRAP_DATA_DIR/hlds
INSTANCE_RUNTIME_DIR="$XDG_RUNTIME_DIR/.pacwrap"

INSTANCE_PACMAN_DIR="$PACWRAP_DATA_DIR/pacman"
INSTANCE_PACMAN_GNUPG="$INSTANCE_PACMAN_DIR/gnupg"
INSTANCE_PACMAN_SYNC="$INSTANCE_PACMAN_DIR/sync"
INSTANCE_PACMAN_MIRRORLIST="$PACWRAP_CONFIG_DIR/pacman.d/mirrorlist"	
INSTANCE_PACMAN_CACHE="$PACWRAP_CACHE_DIR/pkg"
INSTANCE_PACMAN_CFG_DIR="$PACWRAP_CONFIG_DIR/pacman"

init() {
	[[ $EXEC_NAME != "pacwrap" ]] && 
		test_runtime
	
	[[ $SWITCH == *n* ]] && SWITCH_NO_CONFIRM=1
	[[ $SWITCH == *v* ]] && VERBOSE="/dev/stdout"
	[[ $SWITCH == *V* ]] ||
	[[ $SWITCH == h* ]] && manual_script

	[[ ! -f $LOG_FILE ]] && touch $LOG_FILE
	[[ ! $1 ]] && [[ -f $LOCK_FILE ]] && 
		log_error "pacwrap is locked: $LOCK_FILE$RESET" 2

	script_init
	test_datadir
}

load_configuration_all() {
	load_configuration $(ls -U -1F "$INSTANCE_ROOT_DIR" 2>/dev/null | grep ".*[@/]" | tr -d "/@")
}

load_configuration() {
	for instance in $@; do
		source_configuration
		populate_configuration
		populate_container_array
		reset_configuration_params
	done
}

manual_script() {
	VER_DISPLAY=$EXEC_NAME
	source $MAN_SCRIPT
	exit
}

populate_container_array() {
	case ${INSTANCE_CONFIG[$instance,0]} in
		BASE)	BASEROOTDEPS+=($instance);;	
		DEP)	ROOTDEPS+=($instance);;
		ROOT)	ROOTS+=($instance);;
		LINK)	LINKS+=($instance);;
	esac
}

source_configuration() {
	eval $(pacwrap -Axcl $instance)
}


reset_configuration_params() {
	TYPE=; DEPS=; 	
	PKGS=; SYNC_PACMANDB=
}

populate_configuration() {
	INSTANCE_CONFIG[$instance,2]=$SYNC_PACMANDB
}

return_mount() {
	if [[ ! ${INSTANCE_CONFIG[$instance,$CONF_MOUNT]} ]]; then
		echo "ROOT;HOME;"; return; fi
	echo ${INSTANCE_CONFIG[$instance,$CONF_MOUNT]}
}

return_sync_pacmandb() {
	echo ${INSTANCE_CONFIG[$instance,2]}
}

return_base() {
	[[ $(return_type) == "BASE" ]] && echo $instance && return 
	local deps=(${INSTANCE_CONFIG[$instance,1]})
	echo ${deps[0]}
}

return_dependencies() {
	echo ${INSTANCE_CONFIG[$instance,1]}
}

return_packages() {
	echo ${INSTANCE_CONFIG[$instance,3]}
}

return_type() {
	echo ${INSTANCE_CONFIG[$instance,0]}
}

return_dependency() {
	local deps=(${INSTANCE_CONFIG[$instance,1]})
	echo ${deps[$((${#deps[@]} - 1))]}
}

return_pacman_template() {
	echo "$INSTANCE_PACMAN_CFG_DIR/template/pacman.$1$INSTANCE.conf"
}

return_pacman_sync() {
	echo "$INSTANCE_PACMAN_CFG_DIR/sync/pacman.$1$INSTANCE.conf"
}

return_pacman_syncdb() {
	echo "$INSTANCE_PACMAN_CFG_DIR/syncdb/pacman.$1$INSTANCE.conf"
}

log () {
	printf "%s$RESET\n" "$1"
	[[ $2 ]] && case $2 in
		1)	log_to_file "$1";;
		*)	log_to_file "$2";;
	esac
}

log_error() {
	case $1 in
		$LOG_ERR_HELP)	printf "%s %s\n%s\n" "$EXEC_NAME error:" "$2" \
					"Try 'pacwrap -h' for more information on valid operational parameters."
				exit;;
		$ARROW_RED)	printf "$ARROW_RED %s\n %s\n" "$2" "$3"	>&2
				log_to_file "$2"
				[[ $4 ]] && exit $4;;
		$LOG_ERR_WARN)	printf "$BOLD$YELLOW%s$RESET %s\n" "warning:" "$2" >&2
				[[ $3 ]] && exit $3;;
		*)		printf "$BOLD$RED%s$RESET %s\n" "error:" "$1" >&2
				[[ $2 ]] && exit $2;;
	esac
}

log_to_file() {
	printf "[%s] [%s] %s\n" $(date '+%FT%H:%M:%S%z') $EXEC_NAME "$1" >>"$LOG_FILE"
}

print_progress_bar() {	
	printf "\r$PROGRESS_LABEL$RESET"
	printf "%-*s" $(($2+1)) '[' | tr ' ' '#'
	printf "%*s% 3d%%\r"  $(($1-$2))  "]" "$3"
}


init_progress() {
	TTY_SIZE=($(stty size))
	PROGRESS_LENGTH=$((${TTY_SIZE[1]}/2))
}

set_progress_label() {
	[[ $PROGRESS_OFF ]] && printf "\r%s" "$2 $1" && return

	PROGRESS_LABEL="$1"

	local label_length=${#PROGRESS_LABEL}
	local padding_length=$(($PROGRESS_LENGTH-$label_length-8))
	
	[[ $2 ]] && PROGRESS_LABEL="$2 $1" && padding_length=$(($padding_length-3))


	for ((i=0; i<=padding_length; i+=1)); do
		PROGRESS_LABEL+=" "
	done
	
	progress_bar
}

advance_progress() {
	if [[ $amt ]]; then
		((amt_done+=$1))
		progress_bar
	fi
}

progress_bar() {
	[[ $PROGRESS_OFF ]] && return

	local bar_percent=$(($((PROGRESS_LENGTH*2))*$amt_done/$amt % 2 + $PROGRESS_LENGTH*$amt_done/$amt))
	local percent=$((200*$amt_done/$amt % 2 + 100*$amt_done/$amt))
	
	print_progress_bar $((PROGRESS_LENGTH+1)) $bar_percent $percent
}

obtain_explicit_packages() {
	[[ ${PKGLIST_EXPLICIT[$1]} ]] && return
	PKGLIST_EXPLICIT[$1]=$($EXEC_SCRIPT --exec --root --command $1 pacman -Qqe)
	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Query of pacman database failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1
}

get_foreign_packages() {
	local dbsyncpkgs=()
	local deps=$(return_dependencies)	
		
	for dep in ${deps[@]}; do obtain_explicit_packages $dep
		dbsyncpkgs+=("${PKGLIST_EXPLICIT[$dep]}"); done

	echo ${dbsyncpkgs[@]}
}

localized_text() {
	eval "echo \$$1_EN"
}

query_confirm_yN () {
	if [[ $SWITCH_NO_CONFIRM ]]; then		
		echo 1	
		return
	fi
	read -rp "$BAR $@ [y/N]$RESET " input
	if [[ "$input" != "y" ]] && 
	   [[ "$input" != "Y" ]] &&
	   ([[ "$input" == "" ]] ||
	   [[ "$input" != "" ]]); then
		return	
	fi
	echo 1
}

query_confirm_Yn () {
	if [[ $SWITCH_NO_CONFIRM ]]; then		
		echo 1	
		return
	fi
	read -rp "$BAR $@ [Y/n]$RESET " input
	if [[ "$input" != "Y" ]] && 
	   [[ "$input" != "y" ]] &&
           [[ "$input" != "" ]]; then
		return	
	fi
	echo 1
}

test_datadir() {
	([[ ! -d "$PACWRAP_DATA_DIR" ]] ||
	[[ ! -d "$PACWRAP_CACHE_DIR" ]] ||
	[[ ! -d "$PACWRAP_CONFIG_DIR" ]]) && 
		initialize_data_directory

	([[ ! -d "$PACWRAP_DATA_DIR" ]] ||
	[[ ! -d "$PACWRAP_CACHE_DIR" ]] ||
	[[ ! -d "$PACWRAP_CONFIG_DIR" ]]) &&
		log_error "Data directories not found." 2
}

initialize_data_directory() {
	mkdir -p "$PACWRAP_DATA_DIR/root" \
		 "$PACWRAP_DATA_DIR/home" \
		 "$PACWRAP_DATA_DIR/hlds" \
		 "$PACWRAP_DATA_DIR/pacman/sync" \
		 "$PACWRAP_DATA_DIR/pacman/gnupg" \
		 "$PACWRAP_CACHE_DIR/pkg" \
		 "$PACWRAP_CONFIG_DIR/instance" \
		 "$PACWRAP_CONFIG_DIR/pacman.d" \
		 "$PACWRAP_CONFIG_DIR/pacman/sync" \
		 "$PACWRAP_CONFIG_DIR/pacman/syncdb" \
		 "$PACWRAP_CONFIG_DIR/pacman/template" \
		 "$PACWRAP_CONFIG_DIR/bwrap"

	local ins_string="\[options\]"
	local template="\n\n###IGNOREPKG###\n"
	
	([[ ! -f "$INSTANCE_PACMAN_MIRRORLIST" ]] || [[ $SWITCH == *in* ]]) && cp /etc/pacman.d/mirrorlist "$INSTANCE_PACMAN_MIRRORLIST"
	[[ ! -f "$INSTANCE_PACMAN_CFG_DIR/pacman.conf" ]] && echo -e $(pacman_conf) > "$INSTANCE_PACMAN_CFG_DIR/pacman.conf"

	sed -z "s,$ins_string,$ins_string$template,g" < "$INSTANCE_PACMAN_CFG_DIR/pacman.conf" > "$INSTANCE_PACMAN_CFG_DIR/pacman.template.conf"
}

pacman_conf() {
echo $(cat << _CONFIG
[options]\nHoldPkg     = pacman glibc\nArchitecture = auto
\nLogFile     = /tmp/pacman.log
\nNoExtract = etc/pacman.conf etc/pacman.d/mirrorlist
\n\nColor\n#ParallelDownloads = 5
\n\nSigLevel    = Required DatabaseOptional\nLocalFileSigLevel = Optional
\n\n[core]\nInclude = /etc/pacman.d/mirrorlist
\n\n[extra]\nInclude = /etc/pacman.d/mirrorlist
\n\n#[multilib]\n#Include = /etc/pacman.d/mirrorlist
_CONFIG
)
}

generate_config() {
	PACWRAP_PKGS="$@" PACWRAP_DEPS="$(return_dependencies)" PACWRAP_TYPE="$(return_type)" pacwrap -Axcs $instance
}

test_runtime() {
	[[ $(id -u) -lt 1000 ]] && log_error "$EXEC_NAME cannot be executed within a privileged context." 1

	if [[ ! $(type -P bwrap) ]] || [[ ! $(type -P zstd ) ]] || 
	   [[ ! $(type -P fakechroot) ]] || [[ ! $(type -P fakeroot) ]] || 
	   [[ ! $(type -P pacman-key gpg) ]]; then
		cat << _WARN 
$BOLD${RED}error:$RESET Requisite dependencies are missing. 
Please make sure that the following binaries are present in \$PATH:

 ${BOLD}bwrap$RESET, ${BOLD}fakechroot${BOLD}, ${BOLD}fakeroot$RESET, ${BOLD}zstd$RESET, ${BOLD}pacman-key$RESET or ${BOLD}gpg$RESET.

_WARN
		exit 2
	fi
}

function distro_warn() {
	source /etc/os-release
	[[ ! $ID == "arch" ]] && cat << _WARN
$BOLD${RED}WARNING:$RESET You are running pacwrap on an unsupported distribution of Linux or Unix.

Support is not guaranteed. Use at your ${BOLD}OWN$RESET risk.

_WARN
}

log_invalid_arguments() {
	if [[ $1 ]]; then log_error $LOG_ERR_HELP "invalid arguments -- '$RUNTIME_ARGS'"	
		     else log_error "operation not specified." 2; fi
}

test_argument() {
	[[ ! $2 ]] && log_error $LOG_ERR_HELP "$1 not specified." 1
}

check_root() {
	case $1 in
		1)	[[ ! $2 ]] && log_error $LOG_ERR_HELP "Target not specified." 1
			[[ -d "$INSTANCE_ROOT_DIR/$2" ]] &&
				log_error "Target container $BOLD$2$RESET: already exists!" 1;;
		*)	[[ ! $1 ]] && log_error $LOG_ERR_HELP "Target not specified." 1
			[[ ! -d "$INSTANCE_ROOT_DIR/$1" ]] &&
				log_error "Target container $BOLD$1$RESET: not found." 1; esac
}

check_file() {
	case $3 in
		1) 	[[ -f "$2" ]] &&
				log_error "$1 '${2##*/}': already exists!" 1;;
		*)	[[ ! -f "$2" ]] &&
				log_error "$1 '${2##*/}': not found." 1; esac
}
