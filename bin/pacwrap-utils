#!/bin/bash
#
#  PacWrap -- Utility Script
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common
export PACWRAP_UTILS=1

NUMFMT="numfmt --to=si --suffix=B --round=nearest --from-unit=1000 --format=%2f "

main () {
	trap exit INT

	local roots=()
	local rootdeps=()
	local baserootdeps=()
	local syncroots=()
	local links=

	parse_args $@
	init

	[[ $SWITCH != Uls* ]] && log_to_file "Running '$RUNTIME_ARGS'"

	case $SWITCH in
		Uc*)	[[ $(type -p paccache) ]] && 
			paccache --cachedir $INSTANCE_CACHE_DIR ${ARGS[@]};;
		Ui*)	initialize_data_directory;;
		Ur*)	replicate ${baserootdeps[@]} ${rootdeps[@]} ${roots[@]};;
		Uv*)	edit_file 1;;
		Ue*)	edit_file;;		
		Uls*)	summary;;
		Ul*)	link_root;;			
		Ud*)	[[ $SWITCH == *r* ]] && delete "root" "$INSTANCE_ROOT_DIR" 
			[[ $SWITCH == *h* ]] && delete "home" "$INSTANCE_HOME_DIR";;			
		*)	log_invalid_arguments $1
	esac
}

script_init () { 
	[[ $REPLICATION_CONFIG_DIR ]] && 
		INSTANCE_CONFIG_DIR=$REPLICATION_CONFIG_DIR

	local linklist=$($list 2>/dev/null | grep -i "@" | tr -d "@")

	for f in $linklist; do
		links+=($f)
	done

	touch $LOCK_FILE
	trap on_exit EXIT
}

summary() {	
	declare -A size
	local total=0

	[[ $SWITCH == *b* ]] && NUMFMT="echo"

	parse_du

	if [[ $SWITCH != *ddd* ]]; then
		list_root ${baserootdeps[@]} ${rootdeps[@]} ${roots[@]} ${links[@]} | column -t -s "$(echo -e '\t')"
	fi
		
	if [[ $SWITCH == *d* ]]; then			
		local actual_size=${size["root"]}	
		local diff=$(($total - $actual_size))
		
		[[ $diff -le 0 ]] && diff=0

		printf "\n${BOLD}Diskspace consumption summary$RESET\n"
		printf "\n%s\t%s\n" "Total   " "  $($NUMFMT $total)"

		[[ $SWITCH != *dd* ]] || [[ $SWITCH == *dddd* ]] && return

		printf "%s\t%s\n" "Difference" "$UNDERLINE- $($NUMFMT $diff)$RESET"
		printf "%s\t%s\t\n" "${BOLD}Actual$RESET:  " " $($NUMFMT $actual_size)"
	fi
}

parse_args () {
	for var in "$@"; do case $var in 
			--noconfirm|-n)	SWITCH+="n";;
			--list|-ls)	SWITCH+="ls";;
			--edit|-e)	SWITCH+="e";;
			--view|-v)	SWITCH+="v";;
			--replicate|-r)	SWITCH+="r";;
			--delete|-d)	SWITCH+="d";;
			--link|-l)	SWITCH+="l";;
			--tar|-t)	SWITCH+="t";;
			-V|--version)	SWITCH="V";;
			-U*)		SWITCH+=$(echo $var | cut -c 3-);;	
			--cfg-dir=*)	REPLICATION_CONFIG_DIR=$(echo $var | cut -c 11-);;		
			*)		ARGS+=("$var");;
	esac; done
}

replicate() {
	local instances=() 
	local baserootdeps=
	local rootdeps=
	local roots=	

	if [[ $SWITCH == *t* ]]; then	
		local default=$([[ ${#ARGS[@]} -le 1 ]] && echo 1)
		local tar_archive=${ARGS[0]}

		[[ ! $tar_archive ]] && log_error $LOG_ERR_HELP "tar not specified." 1
		[[ ! -f $tar_archive ]] && log_error "tar archive $tar_archive not found." 1


		local tar_list=($(tar tf ${ARGS[0]}))
	
		for file in ${tar_list[@]}; do
			local instance=${file##*/}
			local this=$default
			[[ ! $this ]] && for instance_list in ${ARGS[@]}; do
			[[ "$instance" == "$instance_list" ]] && this=1 && break; done
			[[ ! $instance ]] || [[ ! $this ]] && continue
			eval $(tar axfO $tar_archive $file | grep -v "#")
			populate_configuration
			populate_container_array
			instances+=($instance)
		done
	else
		instances=(${ARGS[@]}) 
		[[ ${#ARGS[@]} -le 0 ]] && instances=$@
		[[ ! $instances ]] && log_error $LOG_ERR_HELP "Instance not specified." 1

		for instance in ${instances[@]}; do		
			[[ ! -f $INSTANCE_CONFIG_DIR/$instance ]] && continue
			source_configuration
			populate_configuration
			populate_container_array
		done
	fi

	[[ ! $SWITCH_NOCONFIRM ]] && echo -e "$BAR Replicate \n\n${instances[@]}\n"	
	[[ ! "$(query_confirm_yN "Proceed with replication?")" ]] && return

	invoke_replication ${baserootdeps[@]} ${rootdeps[@]} ${roots[@]}
}

invoke_replication() {
	if [[ $SWITCH = *d* ]]; then
		printf "$BAR_GREEN %s$RESET\n" "Deleting root instances..."
		for instance in $@; do
			[[ ! -d $INSTANCE_ROOT_DIR/$instance ]] && continue
			rm -rf $INSTANCE_ROOT_DIR/$instance
			printf "$ARROW_GREEN %s$RESET\n" "Deletion of $instance's root complete!"	
			log_to_file "Deleted root $instance."
		done
	fi

	printf "$BAR_GREEN %s$RESET\n" "Replication of root filesystems from configuration..."

	declare -A completed

	for instance in $@; do
		local deps_return=$(return_dependencies)
		local deps=()

		for dep in ${baserootdeps[@]}; do
			for depr in $deps_return; do
				[[ $dep == $depr ]] && deps+=($dep)
			done	
		done
	
		for dep in ${rootdeps[@]}; do
			for depr in $deps_return; do
				[[ $dep == $depr ]] && deps+=($dep)
			done
		done

		for dep in ${deps[@]}; do	
			replicate_instance $dep
		done
		
		for depr in $deps_return; do
			if [[ ! -d $INSTANCE_ROOT_DIR/$depr ]]; then
				log_error $LOG_ERR_HELP "Dependency $depr not fulfilled for $instance."
			fi
		done
	
		replicate_instance $instance
	done

}

replicate_instance() {
	local instance=$1
		       		
	[[ ${completed[$instance]} ]] && return
	
	log_to_file "Beginning replication of $instance."

	local type=$(return_type)
	local params="-Cn"

	[[ $SWITCH == *v* ]] && params+="v"

	case $type in
		BASE)	
			params+="b"
			;;	
		DEP)
			params+="d --dep=$(return_dependency)"
			;;
		ROOT)
			params+=" --dep=$(return_dependency)"
			;;
	esac
	
	$CREATE_SCRIPT $params $instance $(return_packages)
	
	if [[ $? == 0 ]]; then 
		printf " %s$RESET\n" "Replication of $BOLD$instance$RESET complete!"					
		log_to_file "Replication of $instance complete!"
	fi

	completed[$instance]=1
}


delete() {
	local instances=${ARGS[@]};

	[[ ! $instances ]] && log_error $LOG_ERR_HELP "Instance not specified."
	[[ ! $SWITCH_NOCONFIRM ]]  && printf "%s\n\n$BOLD%s\n\n$RESET" "$BAR Delete $1" "$instances"
	[[ ! "$(query_confirm_yN "Proceed with $1?")" ]] && return

	for instance in $instances; do
		if [[ ! -d $2/$instance ]]; then
			log_error $LOG_ERR_WARN "$instance does not exist."
			continue
		fi
		
		rm -rf $2/$instance
		
		printf "$ARROW_GREEN %s$RESET\n" "Deletion of $instance's $1 complete!"					
		log_to_file "Deleted $instance's $1."	
	done
}


link_root() {
	local instance=${ARGS[0]};
	local link=${ARGS[1]};

	[[ ! $instance ]] && log_error $LOG_ERR_HELP "Instance not specified."
	[[ ! $link ]] && log_error $LOG_ERR_HELP "Link not specified."
	[[ -d $INSTANCE_ROOT_DIR/$instance ]] && log_error "$instance already exists." 1
	[[ ! -d $INSTANCE_ROOT_DIR/$link ]] && log_error "Instance $link doesn't exist." 1

	[[ ! $SWITCH_NOCONFIRM ]] && printf "$BAR%s\n\n$BOLD%s\n\n" "Create virtual instance" "$instance $ARROW $BOLD$link"
	[[ ! "$(query_confirm_Yn "Proceed with creation?")" ]] && return

	log "$BAR_GREEN Creating virtual instance $instance $ARROW $BOLD$link"

	ln -s $INSTANCE_ROOT_DIR/$link $INSTANCE_ROOT_DIR/$instance
	mkdir -p $INSTANCE_HOME_DIR/$instance
	echo 'PS1="'$instance'> "' > $INSTANCE_HOME_DIR/$instance/.bashrc

	log "$ARROW_GREEN Process complete!" \
	    "Created $instance -> $link" 
}


parse_du() {
	for string in $(du -d 1 $INSTANCE_ROOT_DIR | tr '	' '-'); do
		local bytes=${string%%-*}
		local instance=${string##*/}

		size["$instance"]=$bytes

		if [[ $SWITCH == *dd* ]] && [[ $SWITCH != *dddd* ]]; then 
			[[ $instance == "root" ]] && continue
			local dh=$(du -d 1 $INSTANCE_ROOT_DIR/$instance | tail -n-1)
		 	bytes=${dh%	*}
			size["$instance"]=$bytes
		fi	

		[[ $instance == "root" ]] && continue
		((total+=bytes))
		
	done
}

list_root() {
	printf "$BOLD%s\t%s\t%s\t%s$RESET\n" "Name" "Dependency" "Size" "Type"

	for instance in $@; do
		local dep=
		local type=	
		local bytes=0

		if [[ ! ${size["$instance"]} ]]; then
			dep="$(ls -l $INSTANCE_ROOT_DIR/$instance | sed -z "s,$INSTANCE_ROOT_DIR/,,g")"
			type="LINK"
		else
			bytes=${size["$instance"]}
			type=$(return_type)
			if [[ $type != BASE ]]; then	
				dep=$(return_dependency)
			else
				dep="-"
			fi
		fi

		printf "%s\t%s\t%s\t%s\n" "$instance" "${dep##*> }" "$($NUMFMT $bytes)" "$type"
	done
}

edit_file() {
		local instance=${ARGS[0]};
		
		local create=
		local dissolve=
		local file=
		local tmpfile=
		local error=	
		
		if [[ ! $EDITOR ]]; then
			EDITOR="vi"
		fi

		[[ ! -f $(type -P $EDITOR) ]] &&
			log_error "\$EDITOR was not found at $EDITOR." 1

		[[ $1 ]] && dissolve=1

		tmpfile=$(mktemp)
		
		case $SWITCH in
			*c*)
				file="$INSTANCE_CONFIG_DIR/$instance"
				error="config file"
			;;
			*b*)
				file="$PACWRAP_CONFIG_DIR/bwrap/$instance.sh"
				error="bubblewrap script $file"
				create=1
				;;	
			*ips*)
				file=$(return_pacman_syncdb $instance)
				error="instanced pacman $file"
				printf "##\n## %s\n" "For the purposes of overview or diagnostics only." > $tmpfile	
				dissolve=1
			;;
			*ip*)
				file=$(return_pacman_sync $instance)
				error="instanced template $file"
				printf "##\n## %s\n" "For the purposes of overview or diagnostics only." > $tmpfile	
				dissolve=1
			;;
			*l*)
				file="$PACWRAP_DATA_DIR/pacwrap.log"
				error="$file"
				dissolve=1
			;;
			*pt*)
				file=$(return_pacman_template $instance)
				error="pacman template $file"
			;;	
			*p*)
				file="$INSTANCE_PACMAN_CFG_DIR/pacman.conf"
				error="default pacman.conf"
			;;	
			*)
				printf "%s%s\n" "$RED$BOLD" "error:$RESET operation not defined."
				return
			;;
		esac


		if ([[ ! -f $file ]] && [[ $dissolve ]]) ||
		   ([[ ! -f $file ]] && [[ ! $create ]]); then
			printf "%s%s\n" "$RED$BOLD" "error:$RESET $error not found."		
			rm $tmpfile
			return
		fi
			
		cat $file >> $tmpfile
		$EDITOR $tmpfile

		local tmp_sum=$(sha256sum $tmpfile) 
		local blank_sum=$(sha256sum /dev/null) 
	
		if [[ "${tmp_sum% *}" != "${blank_sum% *}" ]] && [[ ! $dissolve ]]; then
			local config_sum=$(sha256sum $file)

			if [[ "${tmp_sum% *}" != "${config_sum% *}" ]]; then
				cp $tmpfile $file
				log "$ARROW_GREEN Changes written." \
				    "Changes written to $file."
			else
				log "$ARROW No changes made"
			fi
		else
			log "$ARROW No changes made."
		fi

		rm $tmpfile
}

on_exit () {
	[[ -f $LOCK_FILE ]] && rm $LOCK_FILE
}

main $@
