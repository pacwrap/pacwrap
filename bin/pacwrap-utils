#!/bin/bash
#
#  Pachwrap -- chroot synchronization utility
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
CYAN=$(tput setaf 6)
YELLOW=$(tput setaf 11)
RESET=$(tput sgr0)
UNDERLINE=$(tput smul)

NUMFMT="numfmt --to=si --suffix=B --round=nearest --from-unit=1000 --format=%2f "

BAR="$RED$BOLD::$RESET$BOLD"
BAR_GREEN="$GREEN$BOLD::$RESET$BOLD"
ARROW="$CYAN$BOLD->$RESET"
ARROW_GREEN="$GREEN$BOLD->$RESET"
ARROW_RED="$RED$BOLD->$RESET"

EXEC_NAME="pacwrap-utils"
EXEC_SCRIPT="pacwrap-exec"

main () {
	parse_args $@

	if [[ $SWITCH == *v* ]]; then
		VER_DISPLAY=$EXEC_NAME pacwrap -v 
		exit	
	fi

	local roots=;
	local rootdeps=
	local baserootdeps=
	local links=
	local total=0

	init_vars

	if [[ ! -d $INSTANCE_ROOT ]]; then
		echo $BOLD$RED"error:$RESET Sandbox root is either missing or an environmental variable is misconfigured.$RESET" 
		exit
	fi	

	case $SWITCH in
		c*)
			if [[ -f /usr/bin/paccache ]]; then
				paccache --cachedir $SANDBOX_BASE/var/cache/pacman/pkg/ ${ARGS[@]}
			fi
			;;

		i*)
			initialize_data_directory
			;;
		e*)
			edit_file	
			;;		
		l*)
			link_chroot

			;;			
		d*)
			delete_chroot
			;;			
		s*)
			summary	
			;;
		h*)
			pacwrap --help=utils
			;;
		*)
			if [[ $1 ]]; then
				echo $EXEC_NAME": invalid option -- '$(echo $1 | cut -c 2-)'"
			else
				echo $EXEC_NAME": operation not specified."
			fi
				echo "Try '$EXEC_NAME -h' for more information on valid operational parameters."
			;;

	esac
}

summary() {
	if [[ $SWITCH == *l* ]]; then
		local tmpfile=$(mktemp)

		list_root ${baserootdeps[@]} ${rootdeps[@]} ${roots[@]} ${links[@]} > $tmpfile
		
			cat $tmpfile | column -t
			rm $tmpfile
		fi
		
		if [[ $SWITCH == *d* ]]; then	
		
			[[ ! $SWITCH == *l* ]] && add_total ${roots[@]} ${rootdeps[@]} ${baserootdeps[@]}
				
			local dh=$(du -d 1 $INSTANCE_ROOT | tail -n-1)
			local actual_size=${dh%	*}	
			local diff=$(($total - $actual_size))

			printf "\n${BOLD}Diskspace consumption summary$RESET\n"
			printf "\n%s\t%s\n" "Total   " "  $($NUMFMT $total)"
			printf "%s\t%s\n" "Difference" "$UNDERLINE- $($NUMFMT $diff)$RESET"
			printf "%s\t%s\t\n" "${BOLD}Actual$RESET:  " "  $($NUMFMT $actual_size)"
		fi
}

parse_args () {
	for var in "$@"; do
		case $var in 
			--list|-l)
				SWITCH=l$SWITCH
				;;
			-U*)
				SWITCH=$(echo $var | cut -c 3-)
				;;	
			*)
				ARGS+=("$var")
				;;
			esac
	done
}

init_vars() {
	if [[ ! $SANDBOX_BASE ]]; then
		SANDBOX_BASE="$HOME/.local/share/pacwrap"
	fi 

	INSTANCE_ROOT=$SANDBOX_BASE/fs/root
	INSTANCE_HOME=$SANDBOX_BASE/fs/home
	INSTANCE_DB_ROOT=$SANDBOX_BASE/etc/db
	INSTANCE_CONFIG_ROOT=$SANDBOX_BASE/etc/config
	INSTANCE_PACMAND=$SANDBOX_BASE/etc/pacman.d

	local list="ls -U -1F $INSTANCE_ROOT"
	local rootlist=$($list | grep -i "/" | tr -d "/")
	local linklist=$($list | grep -i "@" | tr -d "@")

	for instance in $rootlist; do
		local type=$(return_type)
		case $type in
			BASE)	
				baserootdeps+=($instance)
				;;	
			DEP)
				rootdeps+=($instance)
				;;
			*)	
				roots+=($instance)
				;;
		esac
	done

	for f in $linklist; do
		links+=($f)
	done
}

delete_chroot() {
	local instance=${ARGS[0]};
			
	if [[ ! $instance ]]; then		
		printf "%s\n%s\n" "$EXEC_NAME: instance not specified." \
		       "Try '$EXEC_NAME -h' for more information on valid operational parameters."
		return
	fi
	printf "%s\n\n$BOLD%s\n\n$RESET" "$BAR Delete instance" "$instance"

	if [[ "$(query_confirm "Proceed with deletion?")" ]]; then
		if [[ ! -d $INSTANCE_ROOT/$instance ]]; then
			echo "$RED${BOLD}error:$RESET $instance does not exist."
			return
		fi
		rm -rf $INSTANCE_ROOT/$instance
			
		printf "$BAR_GREEN %s$RESET\n" "Deletion of $instance complete!"					

		[[ "$(query_confirm "Retain home directory?")" ]] && return
				
		if [[ ! -d $INSTANCE_HOME/$instance ]]; then
			echo "$RED${BOLD}error:$RESET Home $instance does not exist."
			return	
		fi
					
		rm -rf $INSTANCE_HOME/$instance
		printf "$BAR_GREEN %s$RESET\n" "Deletion of $instance's home complete!"
	fi
}


link_chroot() {
		local instance=${ARGS[1]};
		local link=${ARGS[0]};

		if [[ ! $instance ]] || [[ ! $link ]]; then
			printf "%s\n%s\n" "$EXEC_NAME: instance or link not specified." \
			       "Try '$EXEC_NAME -h' for more information on valid operational parameters."	
			return
		fi

		printf "%s\n\n$BOLD%s\n\n" "$BAR Create virtual instance" "$instance $ARROW $link"

		if [[ "$(query_confirm "Proceed with creation?")" ]]; then
			if [[ -d $INSTANCE_ROOT/$instance ]]; then
				echo "$RED${BOLD}error:$RESET $instance already exists."
				return
			fi
			ln -s $INSTANCE_ROOT/$link $INSTANCE_ROOT/$instance

			mkdir -p $INSTANCE_HOME/$instance
			echo 'PS1="'$instance'> "' > $INSTANCE_HOME/$instance/.bashrc

			printf "$BAR_GREEN %s$RESET\n" "Creation of virtual instance $instance complete!"	
		fi	
}


add_total() {
	for instance in $@; do
		local dh=$(du -d 1 $INSTANCE_ROOT/$instance | tail -n-1)
		((total+=${dh%	*}))	
	done
}

list_root() {
	printf "$BOLD%s\t%s\t%s\t%s$RESET\n" "Name" "Dependency" "Size" "Type"

	for instance in $@; do
		local dh=$(du -d 1 $INSTANCE_ROOT/$instance | tail -n-1)
		local bytes=${dh%	*}
		local dep=
		local type=	

		if [[ $bytes == 0 ]]; then
			dep="$(ls -l $INSTANCE_ROOT/$instance | sed -z "s,$INSTANCE_ROOT/,,g")"
			type="LINK"
		else
			type=$(return_type)
			if [[ $type != BASE ]]; then	
				dep=$(return_dependency)
			else
				dep="-"
			fi
		fi

		printf "%s\t%s\t%s\t%s\n" "$instance" "${dep##*> }" "$($NUMFMT $bytes)" "$type"
		((total+=$bytes))
	done
}

edit_file() {
		local dissolve=
		local file=
		local tmpfile=
		local instance=${ARGS[0]};
	
		if [[ ! $EDITOR ]]; then
			EDITOR="vi"
		fi

		if [[ -f $EDITOR ]]; then
			printf "%s%s\n" "$RED$BOLD" "error:$RESET \$EDITOR was not found at $EDITOR."		
			exit	
		fi

		tmpfile=$(mktemp)
		local error=	

		case $SWITCH in
			*c*)
				file="$INSTANCE_CONFIG_ROOT/$instance"
				error="config file"
				if [[ -f $file ]]; then ## TODO: In place until configuration editing supported
					printf "%s\n#\n# %s\n# %s\n#\n\n" "## NOTICE ##" \
					"Configuration editing is currently unsupported." \
					"For the purposes of viewing or diagnostics only." > $tmpfile
					dissolve=1
				fi
			;;

			*pt*)
				file="$SANDBOX_BASE/etc/pacman.$instance.conf"
				error="pacman $instance template"
			;;
			*p*)
				file="$SANDBOX_BASE/etc/pacman.conf"
				error="default pacman.conf"
			;;
			*t*)
				file="$SANDBOX_BASE/etc/pacman.d/tpl/pacman.$instance.conf"
				error="pacman $instance template"
			;;
			*)
				printf "%s%s\n" "$RED$BOLD" "error:$RESET operation not defined."
				return
			;;
		esac

		if [[ ! -f $file ]]; then
			printf "%s%s\n" "$RED$BOLD" "error:$RESET $error not found."		
			return
		fi
				
		cat $file >> $tmpfile
		$EDITOR $tmpfile

		local tmp_sum=$(sha256sum $tmpfile)
		local config_sum=$(sha256sum $file)
		if [[ "${tmp_sum% *}" != "${config_sum% *}" ]] && [[ ! $dissolve ]]; then
			cp $tmpfile $file	
		else
			echo "$BAR_GREEN No changes made.$RESET"
		fi

		rm $tmpfile
}

initialize_data_directory() {
	mkdir -p $SANDBOX_BASE/fs/root \
		$SANDBOX_BASE/fs/home \
		$SANDBOX_BASE/var/cache/pacman/pkg \
		$SANDBOX_BASE/etc/config \
		$SANDBOX_BASE/etc/pacman.d/tpl \
		$SANDBOX_BASE/etc/bwrap

	local ins_string="\[options\]\n"
	local template="\n###IGNOREPKG###\n\n"
	local install="\nNoExtract = usr/lib/*\nNoExtract = usr/lib32/*\nNoExtract = usr/bin/*\nNoExtract = usr/share/*\n\n"

	cp /etc/pacman.d/mirrorlist $SANDBOX_BASE/etc/pacman.d/mirrorlist
	cp /etc/pacman.conf $SANDBOX_BASE/etc/pacman.conf	
	cat $SANDBOX_BASE/etc/pacman.conf | sed -z "s,$ins_string,$ins_string$template,g" > $SANDBOX_BASE/etc/pacman.tpl.conf
	cat $SANDBOX_BASE/etc/pacman.conf | sed -z "s,$ins_string,$ins_string$install,g" > $SANDBOX_BASE/etc/pacman.install.conf
}


return_type() {
	source $INSTANCE_CONFIG_ROOT/$instance
	echo $TYPE
}

return_dependency() {
	source $INSTANCE_CONFIG_ROOT/$instance
	echo ${DEPS[$((${#DEPS[@]} - 1))]}
}

query_confirm () {
	if [[ $SWITCH == *n* ]]; then		
		echo 1	
		return
	fi
	read -rp "$BAR $@ [y/N]$RESET " input
	if [[ "$input" != "y" ]] && 
	   [[ "$input" != "Y" ]] &&
	   ([[ "$input" == "" ]] ||
	   [[ "$input" != "" ]]); then
		return	
	fi
	echo 1
}



main $@
