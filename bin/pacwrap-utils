#!/bin/bash
#
#  PacWrap -- Utility Script
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

BOLD=$(tput bold)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
CYAN=$(tput setaf 6)
YELLOW=$(tput setaf 11)
RESET=$(tput sgr0)
UNDERLINE=$(tput smul)

NUMFMT="numfmt --to=si --suffix=B --round=nearest --from-unit=1000 --format=%2f "

BAR="$RED$BOLD::$RESET$BOLD"
BAR_GREEN="$GREEN$BOLD::$RESET$BOLD"
ARROW="$CYAN$BOLD->$RESET"
ARROW_GREEN="$GREEN$BOLD->$RESET"
ARROW_RED="$RED$BOLD->$RESET"

EXEC_NAME="pacwrap-utils"
EXEC_SCRIPT="pacwrap-exec"

main () {
	parse_args $@

	if [[ $SWITCH == v ]]; then
		VER_DISPLAY=$EXEC_NAME pacwrap -v 
		exit	
	fi

	local roots=;
	local rootdeps=
	local baserootdeps=
	local links=
	local total=0

	init_vars

	if [[ ! -d $INSTANCE_ROOT ]] && [[ $SWITCH != i* ]]; then
		echo $BOLD$RED"error:$RESET Sandbox root is either missing or an environmental variable is misconfigured.$RESET" 
		exit
	fi	

	case $SWITCH in
		c*)
			if [[ -f /usr/bin/paccache ]]; then
				paccache --cachedir $INSTANCE_CACHE_DIR ${ARGS[@]}
			fi
			;;

		i*)
			initialize_data_directory
			;;
		v*)
			edit_file 1
			;;
		e*)
			edit_file	
			;;		
		ls*)
			summary	
			;;
		l*)
			link_root
			;;			
		d*)
			[[ $SWITCH == *r* ]] && delete_root
			[[ $SWITCH == *h* ]] && delete_home
			;;			
		h*)
			pacwrap --help=utils
			;;
		*)
			if [[ $1 ]]; then
				echo $EXEC_NAME": invalid option -- '$(echo $1 | cut -c 2-)'"
			else
				echo $EXEC_NAME": operation not specified."
			fi
				echo "Try '$EXEC_NAME -h' for more information on valid operational parameters."
			;;

	esac
}

summary() {
	declare -A size

	parse_du

	if [[ $SWITCH != *ddd* ]]; then
		local tmpfile=$(mktemp)	
		list_root ${baserootdeps[@]} ${rootdeps[@]} ${roots[@]} ${links[@]} > $tmpfile
		cat $tmpfile | column -t
		rm $tmpfile
	fi
		
	if [[ $SWITCH == *d* ]]; then		
				
		local actual_size=${size["root"]}	
		local diff=$(($total - $actual_size))
		
		[[ $diff -le 0 ]] && diff=0

		printf "\n${BOLD}Diskspace consumption summary$RESET\n"
		printf "\n%s\t%s\n" "Total   " "  $($NUMFMT $total)"
		
		[[ $SWITCH != *dd* ]] || [[ $SWITCH == *dddd* ]] && return

		printf "%s\t%s\n" "Difference" "$UNDERLINE- $($NUMFMT $diff)$RESET"
		printf "%s\t%s\t\n" "${BOLD}Actual$RESET:  " "  $($NUMFMT $actual_size)"
	fi
}

parse_args () {
	for var in "$@"; do
		case $var in 
			--list|-l)
				SWITCH=l$SWITCH
				;;
			-v|--version)
				SWITCH=v
				;;
			-U*)
				SWITCH=$(echo $var | cut -c 3-)
				;;	
			*)
				ARGS+=("$var")
				;;
			esac
	done
}

init_vars() {
	INSTANCE_DATA_DIR="$HOME/.local/share/pacwrap"
	INSTANCE_CACHE_DIR="$HOME/.cache/pacwrap/pkg"
	INSTANCE_CONFIG_DIR="$HOME/.config/pacwrap"

	if [[ $PACWRAP_DEBUG ]]; then 
		INSTANCE_DATA_DIR="$PACWRAP_DEBUG"
		INSTANCE_CONFIG_DIR="$PACWRAP_DEBUG/cfg"	
	fi

	INSTANCE_ROOT=$INSTANCE_DATA_DIR/root
	INSTANCE_HOME=$INSTANCE_DATA_DIR/home
	INSTANCE_DB_ROOT=$INSTANCE_DATA_DIR/database
	INSTANCE_CONFIG_ROOT=$INSTANCE_CONFIG_DIR/root
	INSTANCE_PACMAND=$INSTANCE_CONFIG_DIR/etc/pacman.d

	local list="ls -U -1F $INSTANCE_ROOT"
	local rootlist=$($list | grep -i "/" | tr -d "/")
	local linklist=$($list | grep -i "@" | tr -d "@")

	for instance in $rootlist; do
		local type=$(return_type)
		case $type in
			BASE)	
				baserootdeps+=($instance)
				;;	
			DEP)
				rootdeps+=($instance)
				;;
			*)	
				roots+=($instance)
				;;
		esac
	done

	for f in $linklist; do
		links+=($f)
	done
}


delete_home() {
	local instances=${ARGS[@]};
			
	if [[ ! $instances ]]; then		
		printf "%s\n%s\n" "$EXEC_NAME: instance not specified." \
		       "Try '$EXEC_NAME -h' for more information on valid operational parameters."
		return
	fi

	printf "%s\n\n$BOLD%s\n\n$RESET" "$BAR Delete home" "$instances"

	if [[ "$(query_confirm "Proceed with deletion?")" ]]; then
	
		for instance in $instances; do
			if [[ ! -d $INSTANCE_HOME/$instance ]]; then
				echo "$RED${BOLD}error:$RESET Home $instance does not exist."
				continue
			fi
					
			rm -rf $INSTANCE_HOME/$instance
			printf "$ARROW_GREEN %s$RESET\n" "Deletion of $instance's home complete!"
		done
	fi
}

delete_root() {
	local instances=${ARGS[@]};
			
	if [[ ! $instances ]]; then		
		printf "%s\n%s\n" "$EXEC_NAME: instance not specified." \
		       "Try '$EXEC_NAME -h' for more information on valid operational parameters."
		return
	fi

	printf "%s\n\n$BOLD%s\n\n$RESET" "$BAR Delete instance" "$instances"

	if [[ "$(query_confirm "Proceed with deletion?")" ]]; then

		for instance in $instances; do
			if [[ ! -d $INSTANCE_ROOT/$instance ]]; then
				echo "$RED${BOLD}error:$RESET $instance does not exist."
				continue
			fi
			rm -rf $INSTANCE_ROOT/$instance
			
			printf "$ARROW_GREEN %s$RESET\n" "Deletion of $instance complete!"					
		done

	fi
}


link_root() {
		local instance=${ARGS[1]};
		local link=${ARGS[0]};

		if [[ ! $instance ]] || [[ ! $link ]]; then
			printf "%s\n%s\n" "$EXEC_NAME: instance or link not specified." \
			       "Try '$EXEC_NAME -h' for more information on valid operational parameters."	
			return
		fi

		if [[ -d $INSTANCE_ROOT/$instance ]]; then
			echo "$RED${BOLD}error:$RESET $instance already exists."
			return
		fi

		if [[ ! -d $INSTANCE_ROOT/$link ]]; then
			echo "$RED${BOLD}error:$RESET $link doesn't exist."
			return
		fi

		printf "%s\n\n$BOLD%s\n\n" "$BAR Create virtual instance" "$instance $ARROW $link"

		if [[ "$(query_confirm "Proceed with creation?")" ]]; then
			ln -s $INSTANCE_ROOT/$link $INSTANCE_ROOT/$instance

			mkdir -p $INSTANCE_HOME/$instance
			echo 'PS1="'$instance'> "' > $INSTANCE_HOME/$instance/.bashrc

			printf "$BAR_GREEN %s$RESET\n" "Creation of virtual instance $instance complete!"	
		fi	
}


parse_du() {
	for string in $(du -d 1 $INSTANCE_ROOT | tr '	' '-'); do
		local bytes=${string%%-*}
		local instance=${string##*/}

		size["$instance"]=$bytes
	

		if [[ $SWITCH == *dd* ]] && [[ $SWITCH != *dddd* ]]; then 
			[[ $instance == "root" ]] && continue
			local dh=$(du -d 1 $INSTANCE_ROOT/$instance | tail -n-1)
		 	bytes=${dh%	*}
			size["$instance"]=$bytes
		fi
	
	

		[[ $instance == "root" ]] && continue
		((total+=bytes))
		
	done
}

list_root() {
	printf "$BOLD%s\t%s\t%s\t%s$RESET\n" "Name" "Dependency" "Size" "Type"

	for instance in $@; do
		local dep=
		local type=	
		local bytes=0

		if [[ ! ${size["$instance"]} ]]; then
			dep="$(ls -l $INSTANCE_ROOT/$instance | sed -z "s,$INSTANCE_ROOT/,,g")"
			type="LINK"
		else
			bytes=${size["$instance"]}
			type=$(return_type)
			if [[ $type != BASE ]]; then	
				dep=$(return_dependency)
			else
				dep="-"
			fi
		fi

		printf "%s\t%s\t%s\t%s\n" "$instance" "${dep##*> }" "$($NUMFMT $bytes)" "$type"
	done
}

edit_file() {
		local instance=${ARGS[0]};
		
		local create=
		local dissolve=
		local file=
		local tmpfile=
		local error=	
		
		if [[ ! $EDITOR ]]; then
			EDITOR="vi"
		fi

		if [[ ! -f $EDITOR ]]; then
			printf "%s%s\n" "$RED$BOLD" "error:$RESET \$EDITOR was not found at $EDITOR."		
			exit	
		fi

		[[ $1 ]] && dissolve=1

		tmpfile=$(mktemp)
		
		case $SWITCH in
			*c*)
				file="$INSTANCE_CONFIG_ROOT/$instance"
				error="config file"
			;;
			*b*)
				file="$INSTANCE_CONFIG_DIR/bwrap/$instance.sh"
				error="bubblewrap script $file"
				create=1
				;;	
			*ips*)
				file="$INSTANCE_CONFIG_DIR/pacman/syncdb/pacman.$instance.conf"
				error="instanced pacman $file"
				printf "##\n## %s\n" "For the purposes of overview or diagnostics only." > $tmpfile	
				dissolve=1
			;;
			*ip*)
				file="$INSTANCE_CONFIG_DIR/pacman/sync/pacman.$instance.conf"
				error="instanced template $file"
				printf "##\n## %s\n" "For the purposes of overview or diagnostics only." > $tmpfile	
				dissolve=1
			;;
			*l*)
				file="$INSTANCE_DATA_DIR/pacwrap.log"
				error="$file"
				dissolve=1
			;;
			*pt*)
				file="$INSTANCE_CONFIG_DIR/pacman/template/pacman.$instance.conf"
				error="pacman template $file"
			;;	
			*p*)
				file="$INSTANCE_CONFIG_DIR/pacman/pacman.conf"
				error="default pacman.conf"
			;;	
			*)
				printf "%s%s\n" "$RED$BOLD" "error:$RESET operation not defined."
				return
			;;
		esac


		if ([[ ! -f $file ]] && [[ $dissolve ]]) ||
		   ([[ ! -f $file ]] && [[ ! $create ]]); then
			printf "%s%s\n" "$RED$BOLD" "error:$RESET $error not found."		
			rm $tmpfile
			return
		fi
			
		#sed -r "s/(\x1B\^O|\x1B\[[0-9;]*[JKmsu])//g" 
		cat $file >> $tmpfile
		$EDITOR $tmpfile

		local tmp_sum=$(sha256sum $tmpfile) 
		local blank_sum=$(sha256sum /dev/null) 
	
		if [[ "${tmp_sum% *}" != "${blank_sum% *}" ]] && [[ ! $dissolve ]]; then
			local config_sum=$(sha256sum $file)

			if [[ "${tmp_sum% *}" != "${config_sum% *}" ]]; then
				cp $tmpfile $file
			else
				echo "$BAR_GREEN No changes made.$RESET"
			fi
		else
			echo "$BAR_GREEN No changes made.$RESET"
		fi

		rm $tmpfile
}

initialize_data_directory() {
	mkdir -v -p $INSTANCE_DATA_DIR/root \
		$INSTANCE_DATA_DIR/home \
		$INSTANCE_DATA_DIR/database \
		$INSTANCE_DATA_DIR/pacman/sync \
		$INSTANCE_DATA_DIR/pacman/gnupg \
		$INSTANCE_CACHE_DIR \
		$INSTANCE_CONFIG_DIR/root \
		$INSTANCE_CONFIG_DIR/pacman.d \
		$INSTANCE_CONFIG_DIR/pacman/sync \
		$INSTANCE_CONFIG_DIR/pacman/syncdb \
		$INSTANCE_CONFIG_DIR/pacman/template \
		$INSTANCE_CONFIG_DIR/bwrap

	local ins_string="\[options\]\n"
	local template="\n###IGNOREPKG###\n\n"
	local install="\nNoExtract = usr/lib/*\nNoExtract = usr/lib32/*\nNoExtract = usr/bin/*\nNoExtract = usr/share/*\n\n"
	
	([[ ! -f $INSTANCE_CONFIG_DIR/pacman.d/mirrorlist ]] || [[ $SWITCH == *m* ]]) && cp /etc/pacman.d/mirrorlist $INSTANCE_CONFIG_DIR/pacman.d/mirrorlist
	[[ ! -f $INSTANCE_CONFIG_DIR/pacman/pacman.conf ]] && cp /etc/pacman.conf $INSTANCE_CONFIG_DIR/pacman/pacman.conf	

	cat $INSTANCE_CONFIG_DIR/pacman/pacman.conf | sed -z "s,$ins_string,$ins_string$template,g" > $INSTANCE_CONFIG_DIR/pacman/pacman.template.conf
	cat $INSTANCE_CONFIG_DIR/pacman/pacman.conf | sed -z "s,$ins_string,$ins_string$install,g" > $INSTANCE_CONFIG_DIR/pacman/pacman.install.conf
}


return_type() {
	source $INSTANCE_CONFIG_ROOT/$instance
	echo $TYPE
}

return_dependency() {
	source $INSTANCE_CONFIG_ROOT/$instance
	echo ${DEPS[$((${#DEPS[@]} - 1))]}
}

query_confirm () {
	if [[ $SWITCH == *n* ]]; then		
		echo 1	
		return
	fi
	read -rp "$BAR $@ [y/N]$RESET " input
	if [[ "$input" != "y" ]] && 
	   [[ "$input" != "Y" ]] &&
	   ([[ "$input" == "" ]] ||
	   [[ "$input" != "" ]]); then
		return	
	fi
	echo 1
}

main $@
