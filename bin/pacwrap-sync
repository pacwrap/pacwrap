#!/bin/bash
#
#  PacWrap -- Chroot Synchronization Utility
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common

declare -A updated	
declare -A upgraded
declare -A pkglist
declare -A pkglist_explicit
declare -A synced
declare -A syncreq

EXEC_SCRIPT="$EXEC_SCRIPT  --root --exec"
LINKFILES=("bin" "lib" "lib32" "share")

main () {
	trap abort INT

	local roots=()
	local rootdeps=()
	local baserootdeps=()
	local syncroots=()
	local syncreq=

	parse_args $@
	init $PACWRAP_CREATE

	[[ ! $SWITCH ]] || 
	([[ ! $SYNC_UPDATE ]] && [[ ! $SYNC_UPGRADE ]] && 
	 [[ ! $SYNC_CONFIG ]] && [[ ! $UPDATE_CONFIG ]]) && 
		log_invalid_arguments $@

	if [[ $UPDATE_CONFIG ]] || [[ $SYNC_CONFIG ]]; then
		local instance=${ARGS[0]}
		[[ ! $instance ]] || [[ ! -d $INSTANCE_ROOT_DIR/$instance ]] && return 	
		log "$ARROW Configuring container..."
		[[ $SYNC_CONFIG ]] && sync_pacman_conf
		[[ $UPDATE_CONFIG ]] && update_config
		return
	fi

	if [[ $SYNC_UPGRADE ]] || ([[ $SYNC_UPDATE ]] && [[ ! $SYNC_FORCE ]]); then
		log "$BAR_GREEN Starting container upgrade..."
		if [[ ${ARGS[@]} ]]; then
			[[ ! $SWITCH_NOCONFIRM ]] && echo -e $BAR "Update container \n\n${baserootdeps[@]} ${rootdeps[@]} ${roots[@]}\n"
			[[ ! "$(query_confirm_Yn "Proceed with update?")" ]] && return
		fi
		configure_containers ${baserootdeps[@]} ${rootdeps[@]}
		update ${baserootdeps[@]} ${rootdeps[@]}
	fi

	if [[ ! $SYNC_FORCE ]] && [[ ${#roots[@]} -le 0 ]]; then
		[[ $PACWRAP_PASSTHROUGH ]] && system_update
		log "$ARROW_GREEN Transaction complete."
		return
	fi

	[[ ${#roots[@]} > 0 ]] && [[ ! $SYNC_FORCE ]] && 
		log "$BAR_GREEN Starting contingent container upgrade..."

	for b in ${baserootdeps[@]}; do [[ ${syncreq[$(return_base)]} ]] && syncreq=1 && break; done

	if [[ $SYNC_OVERRIDE ]] || [[ $syncreq ]]; then
		update_links ${syncroots[@]} 
		cleanup_cache ${rootdeps[@]} ${baserootdeps[@]}
		[[ $SYNC_FORCE ]] && return
	fi	

	if [[ $SYNC_UPGRADE ]] || [[ $SYNC_UPDATE ]]; then
		configure_containers ${roots[@]}
		update ${roots[@]}
		[[ $(type -p paccache) ]] && 
			paccache --cachedir $INSTANCE_PACMAN_CACHE $PACWRAP_PACCACHE_ARGUMENTS
	fi

	[[ $PACWRAP_PASSTHROUGH ]] && system_update

	log "$ARROW_GREEN Transaction complete."
}

parse_args () {
	for var in "$@"; do case $var in 
		-V|--version)		SWITCH="V";;
		--generate-config|-g)	SWITCH+="g";;
		--update|-u)		SWITCH+="u";;
		--noconfirm|-n)		SWITCH+="n";;
		--explicit-foreign|-ef)	SWITCH+="ef";;
		--sync|-y)		SWITCH+="y";;		
		-S*)			SWITCH+="${var:2}";;
		*)			ARGS+=("$var");;
	esac; done
}

script_init () {
	log_to_file "Running '$RUNTIME_ARGS'"

	[[ $SWITCH == *g ]] && SYNC_CONFIG=1
	[[ $SWITCH == *gp ]] && UPDATE_CONFIG=1
	[[ $SWITCH == *y* ]] && SYNC_UPDATE=1
	[[ $SWITCH == *u* ]] && SYNC_UPGRADE=1
	[[ $SWITCH == *yy* ]] && SYNC_FOREIGN=1
	[[ $SWITCH == *yyy* ]] && SYNC_OVERRIDE=1
	[[ $SWITCH == *yyyy* ]] && SYNC_FORCE=1
	[[ $SWITCH == *ef* ]] && SYNC_EXPLICIT_FOREIGN=1

	syncroots=(${roots[@]})

	if [[ ${ARGS[@]} ]]; then 
		roots=()
		for instance in $ARGS; do check_root $instance
			[[ $? == 1 ]] && continue
			[[ $(return_type) != "ROOT" ]] && 
			[[ ! $PACWRAP_CREATE ]] && continue 	
			roots+=("$instance")
		done
	fi

	[[ $SYNC_FORCE ]] && syncroots+=(${rootdeps[@]})

	if [[ $PACWRAP_CREATE ]]; then
		local instance=${roots[0]}
		syncroots=($instance)
		for instance in $(return_dependencies); do
			[[ $(return_type) == "BASE" ]] && continue
			syncroots+=($instance)
		done
	fi

	touch $LOCK_FILE
	trap on_exit EXIT
}

invoke_link_deletion() {
	local pwd=$PWD
	local file_old=$link/$item.old.zst
	local file_new=$link/$item.zst
	local working_dir=$root/usr

	([[ ! -f $file_new ]] || [[ ! -f $file_old ]] || [[ ! -d $working_dir ]]) && return

	cd $working_dir
	diff --unchanged-group-format= --new-line-format='%L' \
		-biw <(echo "$(zstd -fd < $file_new)") <(echo "$(zstd -fd < $file_old)") | xargs rm -rf 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
	cd $pwd
}

invoke_update_link() {
	local instance=$1
	local linkfiles=${LINKFILES[@]}

	[[ ${synced[$instance]} ]] && return

	if [[ $(return_type) == "BASE" ]]; then
		invoke_generate_cache
		synced[$instance]=1
		return
	fi

	local dep=$(return_dependency)

	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local link=$INSTANCE_DB_DIR/$dep
		invoke_link_deletion
		#log_to_file "Deleted stray files from $dep/$item in $instance."
		advance_progress 1
	done

	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local source=$INSTANCE_ROOT_DIR/$dep		
		local src=$source/usr/$item 
		local dest=$root/usr/	

		([[ ! -d $src ]] || [[ ! -d $dest ]]) && ((amt_done++)) && continue 

		cp -flR $src $dest 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
		log_to_file "Linked $instance/$item against $dep/$item."	
		advance_progress 1
	done

	[[ $(return_type) == "DEP" ]] && invoke_generate_cache
	[[ $ABORT ]] && exit 1

	synced[$instance]=1
}

update_links() {
	local amt_done=0
	local amt=$((${#@} * 8))
	
	SYNC=1
	init_progress
	set_progress_label "Linking structures" $ARROW

	for instance in "$@"; do check_root $instance
		[[ $? == 1 ]] && continue		
		local syncreq=$SYNC_OVERRIDE
	
		for instance_dep in $(return_dependencies); do check_root $instance_dep
			[[ $? == 1 ]] && break
			[[ $syncreq ]] && invoke_update_link $instance_dep
			[[ ${synced[$instance_dep]} ]] && syncreq=1		
		done

		if [[ $syncreq ]]; then
			invoke_update_link $instance
		else
			advance_progress 8
		fi
	done; SYNC= && echo
}

cleanup_cache() {
	for instance in "$@"; do check_root $instance				
		[[ $? == 1 ]] && continue
	
		local linkfiles=${LINKFILES[@]}
	
		for item in ${linkfiles[@]}; do
			[[ -f $INSTANCE_DB_DIR/$instance/$item.old.zst ]] && 
				rm $INSTANCE_DB_DIR/$instance/$item.old.zst 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
		done
	done
}

invoke_generate_cache() {
	local dep=$instance
	local linkfiles=${LINKFILES[@]}
	
	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local link=$INSTANCE_DB_DIR/$instance
		local rdir=$root/usr/
		local tdir=$root/usr/$item		

		if ([[ ! -d $root ]] || [[ ! -d $tdir ]]); then
			log_error "Root or link target for $BOLD$instance$RESET not found..."
			return
		fi

		[[ -f $link/$item.zst ]] && [[ ! -f $link/$item.old.zst ]] && 
			mv $link/$item.zst $link/$item.old.zst 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
		
		find $tdir -type f,d,l | sed -z "s,$rdir,,g" | zstd -fq -o $link/$item.zst
	done
	log_to_file "Generated link cache for $instance!"
}

check_root() {
	if [[ ! -d $INSTANCE_ROOT_DIR/$1 ]]; then
		log_error $LOG_ERR_WARN "Root for $BOLD$1$RESET not found."
		log_to_file "Root for $1 not found."
		return 1
	fi
}

update_config() {
	declare -A skip

	obtain_explicit_packages $instance

	local old_local_pkgs=$(return_packages)
	local package_list=()
	local local_pkgs=${pkglist_explicit[$instance]}

	if [[ $(return_type) != "BASE" ]]; then
		obtain_explicit_packages $(return_dependency)
		for pkg in ${pkglist_explicit[$(return_dependency)]}; do skip[$pkg]=1; done
	fi

	for pkg in $local_pkgs; do
		[[ ${skip[$pkg]} ]] && continue
		package_list+=("$pkg")
	done

	[[ "$(echo ${package_list[@]})" != "$(echo ${old_local_pkgs[@]})" ]] &&
		generate_config ${package_list[@]}	
	advance_progress 1
}

obtain_explicit_packages() {
	[[ ${pkglist_explicit[$1]} ]] && return
	pkglist_explicit[$1]=$($EXEC_SCRIPT $1 pacman -Qqe)
	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Query of pacman database failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1
}

sync_pacman_conf () {	
	declare -A skip
	
	local dep=$instance

	[[ $(return_type) == "ROOT" ]] && dep=$(return_dependency)
	
	local template="$(return_pacman_template $dep)"
	local pacmanconf="$(return_pacman_sync $instance)"
	local ignorepkg="## Start of automated configuration ##\n"
	
	if [[ $(return_type) != "BASE" ]]; then		
		for depc in $(return_dependencies); do
			obtain_packages $depc
			
			local pkgs=${pkglist[$depc]}
			for pkg in $pkgs; do
				[[ ${skip[$pkg]} ]] && continue
				ignorepkg+="IgnorePkg  = $pkg\n"
				skip[$pkg]=1
			done
		done
	else 
		ignorepkg+="IgnorePkg  = pacman-mirrorlist\n"
	fi

	ignorepkg+="## End of automated configuration ##"
	
	local header="##\n## THIS pacman.conf WAS AUTOMATICALLY GENERATED on $(date "+%F %T"). \n## DO NOT EDIT\n##\n" 

	echo -e $header > $pacmanconf
	sed -z "s/###IGNOREPKG###/$ignorepkg/g" < $template >> $pacmanconf
	advance_progress 1
	syncdb_pacman_conf
}

syncdb_pacman_conf() {
	local pacmanconf=$(return_pacman_syncdb $instance)
	local ignorepkg="## Start of automated configuration ##\n"
	
	obtain_packages $instance

	[[ $(return_type) != "BASE" ]] &&	
		for pkg in ${pkglist[$instance]}; do
			[[ ${skip[$pkg]} ]] && continue
			ignorepkg+="IgnorePkg  = $pkg\n"
		done
	
	ignorepkg+="## End of automated configuration ##"
	echo -e $header > $pacmanconf
	sed -z "s/###IGNOREPKG###/$ignorepkg/g" < $template >> $pacmanconf
	advance_progress 1
}

obtain_packages() {
	[[ ${pkglist[$1]} ]] && return
	pkglist[$1]=$($EXEC_SCRIPT $1 pacman -Qq)
	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Query of pacman database failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1
}

invoke_update() {
	local instance=$1

	[[ ${updated[$instance]} ]] && return
	
	log "$BAR_GREEN Checking $instance for updates..."

	local dbsyncpkgs=
	local type=$(return_type);
	local syncdb=$(return_sync_pacmandb)

	if [[ $SYNC_UPDATE ]] && [[ $type != "ROOT" ]]; then
		if [[ ! $PMSYNCED ]] || [[ $syncdb == 1 ]]; then
			$EXEC_SCRIPT $instance pacman --logfile /tmp/pacman.log -Sy
			[[ $? != 0 ]] && 
				log_error $ARROW_RED "Remote database synchronization failed." \
						     "Use pacwrap -Sv and examine stdout for details." 1
		fi
		PMSYNCED=1
	fi
	
	local result=$($EXEC_SCRIPT $instance pacman --color always -Qu | grep -v "ignored")

	if ([[ $SYNC_OVERRIDE ]] || [[ ${syncreq[$(return_base)]} ]]) && 
	    [[ $type != "ROOT" ]]; then
		log "$ARROW Linking structures..."
		invoke_update_link $instance
	fi

	if ([[ $SYNC_FOREIGN ]] || ([[ $result ]] && [[ $SYNC_UPGRADE ]])) && 
	    [[ $(return_type) != "BASE" ]]; then
		log "$ARROW Synchronizing database against foreign packages..." \
			"Synchronizing $instance against foreign packages"
		
		[[ $SYNC_EXPLICIT_FOREIGN ]] && dbsyncpkgs=$(get_foreign_packages)
		
		$EXEC_SCRIPT $instance pacman -Su \
			--logfile /tmp/pacman.log \
			--dbonly --noconfirm \
			--config=/tmp/pacman.conf ${dbsyncpkgs[@]} 2>$VERBOSE 1>$VERBOSE
		[[ $? != 0 ]] && 
			log_error $ARROW_RED "Foreign database synchronization failed." \
					     "Use pacwrap -Sv and examine stdout for details." 1
		log " Database synchronization complete!"
	fi

	updated[$instance]=1

	if [[ ! $result ]]; then 
		log "$ARROW Container $BOLD$instance$RESET is up to date!"
		return
	fi
	
	echo -e "$BAR Package changes: $RESET \n\n$result\n"
	
	[[ ! $SYNC_UPGRADE ]] && return
	[[ ! $(query_confirm_Yn "Proceed with installation on $instance") ]] && return

	log_to_file "Upgrading $instance container.."
	$EXEC_SCRIPT $instance pacman -Su \
		--logfile /tmp/pacman.log \
		--noconfirm 2>/dev/null

	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Upgrade for $instance failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1

	if [[ $(return_type) != "ROOT" ]]; then
		log "$ARROW Generating link cache..."
		invoke_generate_cache $instance
		synced[$instance]=1
		pkglist[$instance]=
		pkglist_explicit[$instance]=
	fi

	syncreq[$(return_base)]=1
	upgraded[$instance]=$instance

	log "$ARROW_GREEN Upgrade complete!"
}

update () {	
	for instance in "$@"; do check_root $instance
		[[ $? == 1 ]] && continue	
		for dep in $(return_dependencies); do
			invoke_update $dep 
		done

		invoke_update $instance
	done

	[[ ${#upgraded[@]} > 0 ]] && log_to_file "Upgraded containers: $(echo ${upgraded[@]})"
}

system_update() {
	local pacman_args="S"

	[[ $SYNC_UPDATE ]] && pacman_args+="y"
	[[ $SYNC_FOREIGN ]] && pacman_args+="y"
	[[ $SYNC_UPGRADE ]] && pacman_args+="u"

	local pacman="$PACWRAP_PASSTHROUGH_CMD -$pacman_args"
		
	[[ ${#pacman_args} > 0 ]] && 
	[[ $(query_confirm_Yn "Execute $RESET'$YELLOW$pacman$RESET'$BOLD on system") ]] &&
		$pacman
}

configure_containers () {
	local amt=$((${#@}*3))
	local amt_done=0

	init_progress
	set_progress_label "Configuring containers" $ARROW

	for instance in "$@"; do check_root $instance
		[[ $? == 1 ]] && continue
		sync_pacman_conf
		update_config
	done; echo
}

abort () {	
	echo
	ABORT=1
	[[ ! $SYNC ]] && exit
}

on_exit() {
	[[ ! $PACWRAP_CREATE ]] && [[ -f $LOCK_FILE ]] && rm $LOCK_FILE
}

main $@
