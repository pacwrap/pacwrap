#!/bin/bash
#
#  PacWrap -- Chroot Synchronization Utility
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common

declare -A UPDATED
declare -A UPGRADED
declare -A PKGLIST
declare -A SYNCED
declare -A SYNCREQ
declare -A IS_DIFF
declare -A DIFF

EXEC_SCRIPT="$EXEC_SCRIPT  --root --exec"
LINKFILES=("bin" "lib" "lib32" "share")
LINK_OUTPUT_DEST="/dev/null"
LINK_DIFF=0

main () {
	trap abort INT

	local syncroots=()
	local cleanroots=()

	parse_args $@
	init $PACWRAP_CREATE

	[[ ! $SWITCH ]] || 
	([[ ! $SYNC_UPDATE ]] && [[ ! $SYNC_UPGRADE ]] && 
	 [[ ! $SYNC_CONFIG ]] && [[ ! $UPDATE_CONFIG ]]) && 
		log_invalid_arguments $@

	if [[ $UPDATE_CONFIG ]] || [[ $SYNC_CONFIG ]]; then
		local instance=${ARGS[0]}
		[[ ! $instance ]] || [[ ! -d $INSTANCE_ROOT_DIR/$instance ]] && return 	
		log "$ARROW Configuring container..."
		[[ $SYNC_CONFIG ]] && sync_pacman_conf
		[[ $UPDATE_CONFIG ]] && update_config
		return
	fi

	if [[ $SYNC_UPGRADE ]] || ([[ $SYNC_UPDATE ]] && [[ ! $SYNC_FORCE ]]); then
		log "$BAR_GREEN Starting container upgrade..."
		if [[ ! $SWITCH_NOCONFIRM ]] && [[ ${ARGS[@]} ]]; then
			echo -e $BAR "Update container\n\n${BASEROOTDEPS[@]} ${ROOTDEPS[@]} ${ROOTS[@]}\n"
			[[ ! "$(query_confirm_Yn "Proceed with update?")" ]] && return
		fi
		configure_containers ${BASEROOTDEPS[@]} ${ROOTDEPS[@]}
		update ${BASEROOTDEPS[@]} ${ROOTDEPS[@]}
	fi

	if [[ ! ${ARGS[@]} ]] && [[ ! $SYNC_FORCE ]] && [[ ${#ROOTS[@]} -le 0 ]]; then
		[[ $PACWRAP_PASSTHROUGH ]] && system_update
		log "$ARROW_GREEN Transaction complete."
		return
	fi

	local sync=; for b in ${BASEROOTDEPS[@]}; do [[ ${SYNCREQ[$(return_base)]} ]] && sync=1 && break; done

	([[ $SYNC_OVERRIDE ]] || [[ ${#ROOTS[@]} -gt 0 ]]) && [[ ! $SYNC_FORCE ]] && 
		log "$BAR_GREEN Starting contingent container upgrade..."

	if [[ $SYNC_OVERRIDE ]] || [[ $sync ]]; then
		update_links ${syncroots[@]} 
		cleanup_cache ${cleanroots[@]}
		[[ $SYNC_FORCE ]] && return
	fi	

	if [[ ${#ROOTS[@]} -le 0 ]]; then
		[[ $PACWRAP_PASSTHROUGH ]] && system_update
		log "$ARROW_GREEN Transaction complete."
		return
	fi

	if [[ $SYNC_UPGRADE ]] || [[ $SYNC_UPDATE ]]; then
		configure_containers ${ROOTS[@]}
		update ${ROOTS[@]}
		[[ $(type -p paccache) ]] && 
			paccache --cachedir $INSTANCE_PACMAN_CACHE $PACWRAP_PACCACHE_ARGUMENTS
	fi

	[[ $PACWRAP_PASSTHROUGH ]] && system_update
	log "$ARROW_GREEN Transaction complete."
}

parse_args () {
	for var in "$@"; do case $var in 
		-V|--version)		SWITCH="V";;
		--generate-config|-g)	SWITCH+="g";;
		--update|-u)		SWITCH+="u";;
		--noconfirm|-n)		SWITCH+="n";;
		--explicit-foreign|-ef)	SWITCH+="ef";;
		--sync|-y)		SWITCH+="y";;		
		-S*)			SWITCH+="${var:2}";;
		*)			ARGS+=("$var");;
	esac; done
}

script_init () {
	log_to_file "Running '$RUNTIME_EXEC $RUNTIME_ARGS'"

	[[ $SWITCH == *g ]] && SYNC_CONFIG=1
	[[ $SWITCH == *gp ]] && UPDATE_CONFIG=1
	[[ $SWITCH == *y* ]] && SYNC_UPDATE=1
	[[ $SWITCH == *u* ]] && SYNC_UPGRADE=1
	[[ $SWITCH == *yy* ]] && SYNC_FOREIGN=1
	[[ $SWITCH == *yyy* ]] && SYNC_OVERRIDE=1
	[[ $SWITCH == *yyyy* ]] && SYNC_FORCE=1
	[[ $SWITCH == *ef* ]] && SYNC_EXPLICIT_FOREIGN=1
	[[ $SWITCH == *v* ]] && LINK_OUTPUT_DEST=$LOG_FILE
	[[ $SWITCH == *vo* ]] && LINK_OUTPUT_DEST=$VERBOSE


	syncroots=(${ROOTS[@]})
	cleanroots=(${ROOTDEPS[@]} ${BASEROOTDEPS[@]})

	if [[ ${ARGS[@]} ]]; then
		declare -A populated

		local roots=(${ROOTDEPS[@]} ${ROOTS[@]})
		local arg_syncroots=

		ROOTS=()
		BASEROOTDEPS=()
		ROOTDEPS=()
		syncroots=()

		for instance in ${ARGS[@]}; do check_root $instance
			[[ ${populated[$instance]} ]] && continue
	
			populate_container_array
			populated[$instance]=1		
				
			[[ $(return_type) == ROOT ]] && 
				arg_syncroots+=($instance)

			for instance in $(return_dependencies); do check_root $instance
				[[ ${populated[$instance]} ]] && continue

				populate_container_array
				populated[$instance]=1
			done	
		done

		for instance in ${ARGS[@]}; do
			local base_instance=$(return_base)

			for instance in ${roots[@]}; do
				[[ ${populated[$instance]} ]] && continue
				[[ $(return_base) != $base_instance ]] && continue

				syncroots+=($instance)
				populated[$instance]=1
			done
		done
		
		syncroots+=(${arg_syncroots[@]})

		[[ $PACWRAP_CREATE ]] && syncroots=(${ROOTS[@]} ${ROOTDEPS[@]})
	fi

	[[ ! $PACWRAP_CREATE ]] && [[ $SYNC_FORCE ]] && LINK_DIFF=${#ROOTDEPS[@]}

	touch $LOCK_FILE
	trap on_exit EXIT
}

invoke_link_deletion() {
	local pwd=$PWD
	local file_old=$link/$item.old.zst
	local file_new=$link/$item.zst
	local working_dir=$root/usr

	[[ ! ${IS_DIFF[$dep"_"$item]} ]] && return
	([[ ! -f "$file_new" ]] || [[ ! -f "$file_old" ]] || [[ ! -d "$working_dir" ]]) && return
	[[ ! ${DIFF[$dep"_"$item]} ]] &&
		DIFF[$dep"_"$item]=$(diff --unchanged-group-format= --new-line-format='%L' \
			-biw <(echo "$(zstd -fd < "$file_new")") <(echo "$(zstd -fd < "$file_old")"))

	cd "$working_dir"
	IFS=; echo ${DIFF[$dep"_"$item]} | xargs -d '\n' rm -rf 2>>"$LINK_OUTPUT_DEST" 1>>"$LINK_OUTPUT_DEST"; IFS=$' \t\n'
	cd "$pwd"
}

invoke_link_creation() {
	([[ ! -d "$src" ]] || [[ ! -d "$dest" ]]) && return	
	cp -flR "$src" "$dest" 2>>"$LINK_OUTPUT_DEST" 1>>"$LINK_OUTPUT_DEST"
}

invoke_update_link() {
	local instance=$1
	local linkfiles=${LINKFILES[@]}

	[[ ${SYNCED[$instance]} ]] && return

	if [[ $(return_type) == "BASE" ]]; then
		invoke_generate_cache
		SYNCED[$instance]=$instance
		return
	fi

	local dep=$(return_dependency)

	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local link=$INSTANCE_LC_DIR/$dep	
		
		invoke_link_deletion		
		advance_progress 1
	done

	for item in ${linkfiles[@]}; do
		local src=$INSTANCE_ROOT_DIR/$dep/usr/$item 
		local dest=$INSTANCE_ROOT_DIR/$instance/usr/

		invoke_link_creation	
		advance_progress 1
	done

	[[ $(return_type) == "DEP" ]] && invoke_generate_cache
	[[ $ABORT ]] && exit 1

	SYNCED[$instance]=$instance
}

update_links() {
	local amt_done=0
	local amt=$(($((${#@} + $LINK_DIFF)) * 8))
	
	SYNC=1
	init_progress
	set_progress_label "Linking structures" $ARROW

	for instance in "$@"; do check_root $instance
		local syncreq=$SYNC_OVERRIDE
	
		for instance_dep in $(return_dependencies); do check_root $instance_dep
			[[ $syncreq ]] && invoke_update_link $instance_dep
			[[ ${SYNCED[$instance_dep]} ]] && syncreq=1		
		done

		if [[ $syncreq ]]; then
			invoke_update_link $instance
		else
			advance_progress 8
		fi
	done; SYNC= && echo

	log_to_file "Linked containers: $(echo ${SYNCED[@]})"
}

cleanup_cache() {
	for instance in "$@"; do check_root $instance	
		local linkfiles=${LINKFILES[@]}
	
		for item in ${linkfiles[@]}; do
			[[ -f $INSTANCE_LC_DIR/$instance/$item.old.zst ]] && 
				rm "$INSTANCE_LC_DIR/$instance/$item.old.zst" 2>>"$OUTPUT_DEST" 1>>"$OUTPUT_DEST"
		done
	done
}

invoke_generate_cache() {
	local dep=$instance
	local linkfiles=${LINKFILES[@]}
	local log=

	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local link=$INSTANCE_LC_DIR/$instance
		local rdir=$root/usr/
		local tdir=$root/usr/$item		

		if ([[ ! -d "$root" ]] || [[ ! -d "$tdir" ]]); then
			log_error "Root or link target for $BOLD$instance$RESET not found..."
			return
		fi

		[[ -f "$link/$item.zst" ]] && [[ ! -f "$link/$item.old.zst" ]] && 
			mv "$link/$item.zst" "$link/$item.old.zst" 2>>"$OUTPUT_DEST" 1>>"$OUTPUT_DEST"
			
		find "$tdir" -type f,d,l | sed -z "s,$rdir,,g" | zstd -fq -o "$link/$item.zst"

		if [[ -f "$link/$item.old.zst" ]]; then
			local new_sum=$(sha256sum "$link/$item.zst")
			local old_sum=$(sha256sum "$link/$item.old.zst")
	
			if [[ "${old_sum% *}" != "${new_sum% *}" ]]; then
				IS_DIFF[$instance"_"$item]=1; log=1
			fi
		else log=1; fi		
	done

	[[ $log ]] && log_to_file "Generated new hardlink datastore for $instance."
}

update_config() {
	declare -A skip

	obtain_explicit_packages $instance

	local old_local_pkgs=$(return_packages)
	local package_list=()
	local local_pkgs=${PKGLIST_EXPLICIT[$instance]}

	if [[ $(return_type) != "BASE" ]]; then
		obtain_explicit_packages $(return_dependency)
		for pkg in ${PKGLIST_EXPLICIT[$(return_dependency)]}; do skip[$pkg]=1; done
	fi

	for pkg in $local_pkgs; do
		[[ ${skip[$pkg]} ]] && continue
		package_list+=("$pkg")
	done

	[[ "$(echo ${package_list[@]})" != "$(echo ${old_local_pkgs[@]})" ]] &&
		generate_config ${package_list[@]}	
	advance_progress 1
}

sync_pacman_conf () {	
	declare -A skip
	
	local dep=$instance

	[[ $(return_type) == "ROOT" ]] && dep=$(return_dependency)
	
	local template="$(return_pacman_template $dep)"
	local pacmanconf="$(return_pacman_sync $instance)"
	local ignorepkg="## Start of automated configuration ##\n"
	
	[[ $(return_type) != "BASE" ]] &&
		for depc in $(return_dependencies); do
			obtain_packages $depc

			local pkgs=${PKGLIST[$depc]}
			for pkg in $pkgs; do
				[[ ${skip[$pkg]} ]] && continue
				ignorepkg+="IgnorePkg  = $pkg\n"
				skip[$pkg]=1
			done
		done

	ignorepkg+="## End of automated configuration ##"
	
	local header="##\n## THIS pacman.conf WAS AUTOMATICALLY GENERATED on $(date "+%F %T"). \n## DO NOT EDIT\n##\n" 

	echo -e $header > "$pacmanconf"
	sed -z "s/###IGNOREPKG###/$ignorepkg/g" < "$template" >> "$pacmanconf"
	advance_progress 1
	syncdb_pacman_conf
}

syncdb_pacman_conf() {
	local pacmanconf=$(return_pacman_syncdb $instance)
	local ignorepkg="## Start of automated configuration ##\n"
	
	obtain_packages $instance

	[[ $(return_type) != "BASE" ]] &&	
		for pkg in ${PKGLIST[$instance]}; do
			[[ ${skip[$pkg]} ]] && continue
			ignorepkg+="IgnorePkg  = $pkg\n"
		done
	
	ignorepkg+="## End of automated configuration ##"
	echo -e $header > "$pacmanconf"
	sed -z "s/###IGNOREPKG###/$ignorepkg/g" < "$template" >> "$pacmanconf"
	advance_progress 1
}

obtain_packages() {
	[[ ${PKGLIST[$1]} ]] && return
	PKGLIST[$1]=$($EXEC_SCRIPT $1 pacman -Qq)
	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Query of pacman database failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1
}

invoke_update() {
	local instance=$1

	[[ ${UPDATED[$instance]} ]] && return
	
	log "$BAR_GREEN Checking $instance for updates..."

	local dbsyncpkgs=
	local type=$(return_type);
	local syncdb=$(return_sync_pacmandb)

	if [[ $SYNC_UPDATE ]] && [[ $type != "ROOT" ]]; then
		if [[ ! $PMSYNCED ]] || [[ $syncdb == 1 ]]; then
			$EXEC_SCRIPT $instance pacman --logfile /tmp/pacman.log -Sy
			[[ $? != 0 ]] && 
				log_error $ARROW_RED "Remote database synchronization failed." \
						     "Use pacwrap -Sv and examine stdout for details." 1
		fi
		PMSYNCED=1
	fi
	
	local result=$($EXEC_SCRIPT $instance pacman --color always -Qu | grep -v "ignored")

	if ([[ $SYNC_OVERRIDE ]] || [[ ${SYNCREQ[$(return_base)]} ]]) && 
	    [[ $type != "ROOT" ]]; then
		log "$ARROW Linking structures..."
		invoke_update_link $instance
	fi

	if ([[ $SYNC_FOREIGN ]] || ([[ $result ]] && [[ $SYNC_UPGRADE ]])) && 
	    [[ $(return_type) != "BASE" ]]; then
		log "$ARROW Synchronizing database against foreign packages..." \
			"Synchronizing $instance against foreign packages"
		
		[[ $SYNC_EXPLICIT_FOREIGN ]] && dbsyncpkgs=($(get_foreign_packages))
		
		$EXEC_SCRIPT $instance pacman -Su \
			--logfile /tmp/pacman.log \
			--dbonly --noconfirm \
			--config=/tmp/pacman.conf ${dbsyncpkgs[@]} 2>$VERBOSE 1>$VERBOSE
		[[ $? != 0 ]] && 
			log_error $ARROW_RED "Foreign database synchronization failed." \
					     "Use pacwrap -Sv and examine stdout for details." 1
		log " Database synchronization complete!"
	fi

	UPDATED[$instance]=$instance

	if [[ ! $result ]]; then 
		log "$ARROW Container $BOLD$instance$RESET is up to date!"
		return
	fi
	
	echo -e "$BAR Package changes: $RESET \n\n$result\n"
	
	[[ ! $SYNC_UPGRADE ]] && return
	[[ ! $(query_confirm_Yn "Proceed with installation on $instance") ]] && return

	log_to_file "Upgrading $instance container.."
	$EXEC_SCRIPT $instance pacman -Su \
		--logfile /tmp/pacman.log \
		--noconfirm 2>$VERBOSE

	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Upgrade for $instance failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1

	if [[ $(return_type) != "ROOT" ]]; then
		log "$ARROW Generating link datastore..."
		invoke_generate_cache $instance
		SYNCED[$instance]=$instance
		PKGLIST[$instance]=
		PKGLIST_EXPLICIT[$instance]=
	fi

	SYNCREQ[$(return_base)]=1
	UPGRADED[$instance]=$instance

	log "$ARROW_GREEN Upgrade complete!"
}

update () {	
	for instance in "$@"; do check_root $instance
		for dep in $(return_dependencies); do
			invoke_update $dep 
		done

		invoke_update $instance
	done

	[[ ${#UPGRADED[@]} > 0 ]] && log_to_file "Upgraded containers: $(echo ${UPGRADED[@]})"
}

system_update() {
	local pacman_args="S"

	[[ $SYNC_UPDATE ]] && pacman_args+="y"
	[[ $SYNC_FOREIGN ]] && pacman_args+="y"
	[[ $SYNC_UPGRADE ]] && pacman_args+="u"

	local pacman="$PACWRAP_PASSTHROUGH_CMD -$pacman_args"
		
	[[ ${#pacman_args} > 0 ]] && 
	[[ $(query_confirm_Yn "Execute $RESET'$YELLOW$pacman$RESET'$BOLD on system") ]] &&
		$pacman
}

configure_containers () {
	local amt=$((${#@}*3))
	local amt_done=0

	init_progress
	set_progress_label "Configuring containers" $ARROW

	for instance in "$@"; do check_root $instance
		sync_pacman_conf
		update_config
	done; echo
}

abort () {	
	echo; ABORT=1; [[ ! $SYNC ]] && exit
}

on_exit() {
	[[ ! $PACWRAP_CREATE ]] && [[ -f "$LOCK_FILE" ]] && rm "$LOCK_FILE"
}

main $@
