#!/bin/bash
#
#  PacWrap -- Chroot Synchronization Utility
# 
#  Copyright (C) 2023 Xavier R.M. 
#  sapphirus(at)azorium(dot)net
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, with only version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

source pacwrap-common

declare -A updated	
declare -A synced
declare -A syncreq

EXEC_NAME="pacwrap-sync"
EXEC_SCRIPT="pacwrap-exec --root --exec"

LINKFILES=("bin" "lib" "lib32" "share")

main () {
	export PACWRAP_UTILS=1
	trap abort INT

	local roots=()
	local rootdeps=()
	local baserootdeps=()
	local syncroots=()
	local syncreq=

	parse_args $@
	init $PACWRAP_CREATE

	[[ ! $SWITCH ]] && log_error "No switch provided." 1

	if [[ $SWITCH == *g* ]]; then
		log "$ARROW Configuring container..."
		local instance=${ARGS[0]}
		check_root "pacman.conf generation"
		sync_pacman_conf
		exit
	fi

	if [[ $SYNC_UPGRADE ]] || ([[ $SYNC_UPDATE ]] && [[ ! $SYNC_FORCE ]]); then
		log "$BAR_GREEN Starting container upgrade..."
		[[ ! $SWITCH_NOCONFIRM ]] && echo -e $BAR "Update container \n\n${baserootdeps[@]} ${rootdeps[@]} ${roots[@]}\n"
		[[ ! "$(query_confirm_Yn "Proceed with update?")" ]] && return
		configure_containers ${baserootdeps[@]} ${rootdeps[@]}
		update ${baserootdeps[@]} ${rootdeps[@]}
	fi

	[[ ${#roots[@]} > 0 ]] && [[ ! $SYNC_FORCE ]] && 
		log "$BAR_GREEN Starting contingent container upgrade..."

	for b in ${baserootdeps[@]}; do
		[[ ${syncreq[$(return_base)]} ]] && syncreq=1 && break; done

	if [[ $SYNC_OVERRIDE ]] || [[ $syncreq ]]; then
		update_links ${syncroots[@]} 
		cleanup_cache ${rootdeps[@]} ${baserootdeps[@]}
		[[ $SYNC_FORCE ]] && return
	fi
	
	[[ ${#roots[@]} -le 0 ]] && return

	if [[ $SYNC_UPGRADE ]] || [[ $SYNC_UPDATE ]]; then
		configure_containers ${roots[@]}
		update ${roots[@]}
		[[ -f /usr/bin/paccache ]] && 
			paccache --cachedir $INSTANCE_PACMAN_CACHE -r -k 1 --min-mtime "14 days ago"
		
	fi
}

parse_args () {
	for var in "$@"; do
		case $var in 
			--generate-config|-g)
				SWITCH=g$SWITCH
				;;
			--update|-u)
				SWITCH=u$SWITCH
				;;
			--no-confirm|-n)
				SWITCH=n$SWITCH
				;;
			--sync|-y)
				SWITCH=y$SWITCH
				;;		
			-S*)
				SWITCH=$(echo $var | cut -c 3-)
				;;
			*)
				ARGS+=("$var")
				;;
			esac
	done
}

script_init () {
	log_to_file "Running '$RUNTIME_ARGS'"

	[[ $SWITCH == *y* ]] && SYNC_UPDATE=1
	[[ $SWITCH == *u* ]] && SYNC_UPGRADE=1
	[[ $SWITCH == *yy* ]] && SYNC_FOREIGN=1
	[[ $SWITCH == *yyy* ]] && SYNC_OVERRIDE=1
	[[ $SWITCH == *yyyy* ]] && SYNC_FORCE=1

	syncroots=(${roots[@]})

	if [[ ${ARGS[@]} ]]; then 
		roots=()
		for instance in $ARGS; do
			check_root "container" 
			[[ $? == 1 ]] && continue
			[[ $(return_type) != "ROOT" ]] && 
			[[ ! $PACWRAP_CREATE ]] && continue 	
			roots+=("$instance")
		done
	fi

	[[ $SYNC_FORCE ]] && syncroots+=(${rootdeps[@]})

	if [[ $PACWRAP_CREATE ]]; then
		local instance=${roots[0]}
		syncroots=($instance)
		for instance in $(return_dependencies); do
			[[ $(return_type) == "BASE" ]] && continue
			syncroots+=($instance)
		done
	fi

	touch $LOCK_FILE
	trap on_exit EXIT
}

invoke_link_deletion() {
	local pwd=$PWD
	local file_old=$link/$item.old.zst
	local file_new=$link/$item.zst
	local working_dir=$root/usr

	([[ ! -f $file_new ]] || [[ ! -f $file_old ]] || [[ ! -d $working_dir ]]) && return

	cd $working_dir
	diff --unchanged-group-format= --new-line-format='%L' \
		-biw <(echo "$(zstd -fd < $file_new)") <(echo "$(zstd -fd < $file_old)") | xargs rm -rf 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
	cd $pwd
}

invoke_update_link() {
	local instance=$1
	local linkfiles=${LINKFILES[@]}

	[[ ${synced[$instance]} ]] && return

	if [[ $(return_type) == "BASE" ]]; then
		invoke_generate_cache
		synced[$instance]=1
		return
	fi

	local dep=$(return_dependency)

	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local link=$INSTANCE_DB_DIR/$dep
		invoke_link_deletion
		#log_to_file "Deleted stray files from $dep/$item in $instance."
		advance_progress 1
	done

	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local source=$INSTANCE_ROOT_DIR/$dep		
		local src=$source/usr/$item 
		local dest=$root/usr/	

		([[ ! -d $src ]] || [[ ! -d $dest ]]) && ((amt_done++)) && continue 

		cp -flR $src $dest 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
		log_to_file "Linked $instance/$item against $dep/$item."	
		advance_progress 1
	done

	[[ $(return_type) == "DEP" ]] && invoke_generate_cache
	[[ $ABORT ]] && exit 1

	synced[$instance]=1
}

update_links() {
	local amt_done=0
	local amt=$((${#@} * 8))
	local check_root="link synchronization"
	
	SYNC=1
	init_progress
	set_progress_label "Linking structures" $ARROW

	for instance in "$@"; do check_root $check_root
		[[ $? == 1 ]] && continue		
		local syncreq=$SYNC_OVERRIDE
	
		for instance_dep in $(return_dependencies); do check_root $check_root
			[[ $? == 1 ]] && break
			[[ $syncreq ]] && invoke_update_link $instance_dep
			[[ ${synced[$instance_dep]} ]] && syncreq=1		
		done

		if [[ $syncreq ]]; then
			invoke_update_link $instance
		else
			advance_progress 8
		fi
	done; SYNC= && echo
}

cleanup_cache() {
	for instance in "$@"; do				
		check_root "cache file operation"
		[[ $? == 1 ]] && continue
	
		local linkfiles=${LINKFILES[@]}
	
		for item in ${linkfiles[@]}; do
			[[ -f $INSTANCE_DB_DIR/$instance/$item.old.zst ]] && 
				rm $INSTANCE_DB_DIR/$instance/$item.old.zst 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
		done
	done
}

invoke_generate_cache() {
	local dep=$instance
	local linkfiles=${LINKFILES[@]}
	
	for item in ${linkfiles[@]}; do
		local root=$INSTANCE_ROOT_DIR/$instance
		local link=$INSTANCE_DB_DIR/$instance
		local rdir=$root/usr/
		local tdir=$root/usr/$item		

		if ([[ ! -d $root ]] || [[ ! -d $tdir ]]); then
			log_error "Root or link target for $BOLD$instance$RESET not found..."
			return
		fi

		[[ -f $link/$item.zst ]] && mv $link/$item.zst $link/$item.old.zst 2>>$OUTPUT_DEST 1>>$OUTPUT_DEST
		find $tdir -type f,d,l | sed -z "s,$rdir,,g" | zstd -fq -o $link/$item.zst
	done
	log_to_file "Generated link cache for $instance!"
}

check_root() {
	if [[ ! -d $INSTANCE_ROOT_DIR/$instance ]]; then
		log_error $LOG_ERR_WARN "Root for $BOLD$instance$RESET not found."
		log_to_file "Root for $instance not found."
		return 1
	fi
}

update_config() {
	declare -A skip
	
	local i=
	local old_local_pkgs=$(return_packages)
	local package_list=()
	local local_pkgs=$($EXEC_SCRIPT $instance pacman -Qqe)
	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Query of pacman database failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1
	
	if [[ $(return_type) != "BASE" ]]; then
		local pkgs=$($EXEC_SCRIPT $(return_dependency) pacman -Qqe)
	
		for pkg in $pkgs; do
			skip[$pkg]=1
		done
	fi

	for pkg in $local_pkgs; do
		[[ ${skip[$pkg]} ]] && continue
		package_list[i++]="$pkg"
	done

	[[ "$(echo ${package_list[@]})" != "$(echo ${old_local_pkgs[@]})" ]] &&
		generate_config ${package_list[@]}
	
	((amt_done++))
	progress_bar
}

sync_pacman_conf () {	
	local dep=$instance

	[[ $(return_type) == "ROOT" ]] && dep=$(return_dependency)
	
	declare -A skip
	local template="cat $(return_pacman_template $dep)"
	local pacmanconf=$(return_pacman_sync $instance)
	local ignorepkg="## Start of automated configuration ##\n"
	
	if [[ $(return_type) != "BASE" ]]; then		
		for depc in $(return_dependencies); do
			local skiplist=
			local pkgs=$($EXEC_SCRIPT $depc pacman -Qq)
			[[ $? != 0 ]] && 
				log_error $ARROW_RED "Query of pacman database failed." \
						     "Use pacwrap -Sv and examine stdout for details."
			for pkg in $pkgs; do
			 	[[ ${skip[$pkg]} ]] && continue
				ignorepkg+="IgnorePkg  = $pkg\n"
			done			
			skiplist=$pkgs$skiplist

			for pkg in $skiplist; do
				skip[$pkg]=1
			done
		done
	else 
		ignorepkg+="IgnorePkg  = pacman-mirrorlist\n"
	fi

	ignorepkg+="## End of automated configuration ##"
	
	local header="##\n## THIS pacman.conf WAS AUTOMATICALLY GENERATED on $(date "+%F %T"). \n## DO NOT EDIT\n##\n" 

	echo -e $header > $pacmanconf
	$template | sed -z "s/###IGNOREPKG###/$ignorepkg/g" >> $pacmanconf
	advance_progress 1
	syncdb_pacman_conf	
}

syncdb_pacman_conf() {
	local pacmanconf=$(return_pacman_syncdb $instance)
	local ignorepkg="## Start of automated configuration ##\n"
	local local_pkgs=$($EXEC_SCRIPT $instance pacman -Qq)
	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Query of pacman database failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1
	
	if [[ $(return_type) != "BASE" ]]; then	
		for pkg in $local_pkgs; do
			[[ ${skip[$pkg]} ]] && continue
			ignorepkg+="IgnorePkg  = $pkg\n"
		done
	fi
	
	ignorepkg+="## End of automated configuration ##"
	echo -e $header > $pacmanconf
	$template | sed -z "s/###IGNOREPKG###/$ignorepkg/g" >> $pacmanconf
	advance_progress 1
}

invoke_update() {
	local instance=$1

	[[ ${updated[$instance]} ]] && return
	updated[$instance]=1
	log "$BAR_GREEN Checking $instance for updates..."

	local type=$(return_type);
	local syncdb=$(return_sync_pacmandb)

	if [[ $SYNC_UPDATE ]] && [[ $type != "ROOT" ]]; then
		if [[ ! $PMSYNCED ]] || [[ $syncdb == 1 ]]; then
			$EXEC_SCRIPT $instance pacman --logfile /tmp/pacman.log -Sy
			[[ $? != 0 ]] && 
				log_error $ARROW_RED "Remote database synchronization failed." \
						     "Use pacwrap -Sv and examine stdout for details." 1
		fi
		PMSYNCED=1
	fi

	local result=$($EXEC_SCRIPT $instance pacman --color always -Qu | grep -v "ignored")

	if ([[ $SYNC_OVERRIDE ]] || [[ ${syncreq[$(return_base)]} ]]) && 
	    [[ $type != "ROOT" ]]; then
		log "$ARROW Linking structures..."
		invoke_update_link $instance
	fi

	if ([[ $SYNC_FOREIGN ]] || ([[ $result ]] && [[ $SYNC_UPGRADE ]])) && 
	    [[ $(return_type) != "BASE" ]]; then
		log "$ARROW Synchronizing database against foreign packages..." \
			"Synchronizing $instance against foreign packages"
		$EXEC_SCRIPT $instance pacman -Su \
			--logfile /tmp/pacman.log \
			--dbonly --noconfirm \
			--config=/tmp/pacman.conf 2>/dev/null 1>$VERBOSE

		[[ $? != 0 ]] && 
			log_error $ARROW_RED "Foreign database synchronization failed." \
					     "Use pacwrap -Sv and examine stdout for details." 1

		log " Database synchronization complete!"
	fi

	if [[ ! $result ]]; then 
		log "$ARROW Container $BOLD$instance$RESET is up to date!"
		return
	fi
	
	echo -e "$BAR Package changes: $RESET \n\n$result\n"
	
	[[ ! $SYNC_UPGRADE ]] && return
	[[ ! $(query_confirm_Yn "Proceed with installation on $instance") ]] && return

	log_to_file "Upgrading $instance container.."
	$EXEC_SCRIPT $instance pacman -Su \
		--logfile /tmp/pacman.log \
		--noconfirm 2>/dev/null

	[[ $? != 0 ]] && 
		log_error $ARROW_RED "Upgrade for $instance failed." \
				     "Use pacwrap -Sv and examine stdout for details." 1

	if [[ $(return_type) != "ROOT" ]]; then
		log "$ARROW Generating link cache..."
		invoke_generate_cache $instance
		synced[$instance]=1
	fi

	syncreq[$(return_base)]=1

	log "$ARROW_GREEN Upgrade complete!"
}

update () {	
	for instance in "$@"; do	
		check_root "update"
		[[ $? == 1 ]] && continue	
		for dep in $(return_dependencies); do
			invoke_update $dep 
		done

		invoke_update $instance
	done
}


configure_containers () {	
	local amt=$((${#@}*3))
	local amt_done=0

	init_progress
	set_progress_label "Configuring containers" $ARROW

	for instance in "$@"; do check_root "pacman.conf generation"
		[[ $? == 1 ]] && continue	
		sync_pacman_conf
	done

	for instance in "$@"; do check_root "configuration update"
		[[ $? == 1 ]] && continue	
		update_config
	done; echo

	log_to_file "Configured containers: $@"
}

abort () {	
	echo
	ABORT=1
	[[ ! $SYNC ]] && exit
}

on_exit() {
	[[ ! $PACWRAP_CREATE ]] && [[ -f $LOCK_FILE ]] && rm $LOCK_FILE
}

main $@
